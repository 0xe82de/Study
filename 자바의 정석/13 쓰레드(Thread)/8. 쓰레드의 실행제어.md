# 8. 쓰레드의 실행제어

쓰레드 프로그래밍이 어려운 이유는 `동기화(synchronization)`와 `스케줄링(scheduling)`때문이다. 효율적인 멀티쓰레드 프로그램을 만들기 위해서는 보다 정교한 스케줄링을 통해 프로세스에게 주어진 자원과 시간을 여러 쓰레드가 낭비없이 잘 사용하도록 개발해야 한다.

쓰레드의 스케줄링과 관련된 메서드는 다음과 같다.

| 메서드                                                                      | 설명                                                                                                                                                                |
| --------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| static void sleep(long millis)<br>static void sleep(long millis, int nanos) | 지정된 시간(천분의 일초 단위)동안 쓰레드를 일시정지시킨다. 지정한 시간이 지나고 나면, 자동으로 다시 실행대기상태가 된다.                                            |
| void join()<br>void join(long millis)<br>void join(long millis, int nanos)  | 지정된 시간동안 쓰레드가 실행되도록 한다. 지정된 시간이 지나거나 작업이 종료되면 join()을 호출한 쓰레드로 다시 돌아와 실행을 계속한다.                              |
| void interrupt()                                                            | sleep()이나 join()에 의해 일시정지상태인 쓰레드를 깨워서 실행대기상태로 만든다. 해당 쓰레드에서는 interruptedException이 발생함으로써 일시정지상태를 벗어나게 된다. |
| void stop()                                                                 | 쓰레드를 즉시 종료시킨다.                                                                                                                                           |
| void sustpend()                                                             | 쓰레드를 일시정지시킨다. resume()을 호출하면 다시 실행대기상태가 된다.                                                                                              |
| void resume()                                                               | suspend()에 의해 일시정지상태에 있는 쓰레드를 실행대기상태로 만든다.                                                                                                |
| static voic yield()                                                         | 실행 중에 자신에게 주어진 실행시간을 다른 쓰레드에게 양보(yield)하고 자신은 실행대기상태가 된다.                                                                    |

쓰레드의 상태는 다음과 같다.

| 상태                     | 설명                                                                                                                                    |
| ------------------------ | --------------------------------------------------------------------------------------------------------------------------------------- |
| NEW                      | 쓰레드가 생성되고 아직 start()가 호출되지 않은 상태                                                                                     |
| RUNNABLE                 | 실행 중 또는 실행 가능한 상태                                                                                                           |
| BLOCKED                  | 동기화블럭에 의해서 일시정지된 상태(lock이 풀릴 때까지 기다리는 상태)                                                                   |
| WAITING<br>TIMED_WAITING | 쓰레드의 작업이 종료되지는 않았지만 실행가능하지 않은(unrunnable) 일시정지 상태. TIMED_WAITING은 일시정지시간이 지정된 경우를 의미한다. |
| TERMINATED               | 쓰레드의 작업이 종료된 상태                                                                                                             |

### sleep(long millis) - 일정시간동안 쓰레드를 멈추게 한다.

`sleep()`은 지정된 시간동안 쓰레드를 멈추게 한다.

```Java
static void sleep(long millis)
static void sleep(long millis, int nanos)
```

밀리세컨드(millis, 1000분의 일초)와 나노세컨드(nanos, 10억분의 일초)의 시간단위로 세밀하게 값을 지정할 수 있지만 어느정도 오차가 발생할 수 있다. 쓰레드를 0.0015초 동안 멈추게 하려면 다음과 같이 한다.

```Java
try {
    Thread.sleep(1, 500000); // 쓰레드를 0.0015초 동안 멈추게 한다.
} catch (InterruptedException e) {}
```

`sleep()`에 의해 일시정지 상태가 된 쓰레드는 지정된 시간이 다 되거나 `interrupt()`가 호출되면(InterruptedException 발생), 실행대기 상태가 된다. 그래서 `sleep()`을 호출할 때는 항상 `try-catch`문으로 예외를 처리해줘야 하는데, 매번 예외처리를 해주는 것이 번거롭기 때문에, 아래와 같이 `try-catch`문을 포함하는 새로운 메서드를 만들어서 사용하기도 한다.

```Java
void delay(long millis) {
    try {
        Thread.sleep(millis);
    } catch (InterruptedException e) {}
}
```

### interrupt()와 interrupted() - 쓰레드의 작업을 취소한다.

진행 중인 쓰레드의 작업이 끝나기 전에 취소시켜야할 때가 있다. 예를 들어 큰 파일을 다운로드받을 때 시간이 너무 오래 걸리면 중간에 취소할 수 있어야 한다.

`interrupt()`는 쓰레드에게 작업을 멈추라고 요청한다. 단지 멈추라고 요청만 하는 것이고, 강제로 종료시키지는 못한다. `interrupt()`는 단지 쓰레드의 `interrupted` 상태(인스턴스 변수)를 바꾸는 것일 뿐이다.

`interrupted()`는 쓰레드에 대해 `interrupt()`가 호출되었는지 알려준다. 호출되지 않았으면 `false`를, 호출되었다면 `true`를 반환한다.

```Java
Thread th = new Thread();
th.start();

th.interrupt(); // 쓰레드 th에 interrupt()를 호출한다.

class MyThread extends Thread {
    public void run() {
        while (!interrupted()) { // interrupted()의 결과가 false인 동안 반복
            ...
        }
    }
}
```

`isInterrupted()`도 쓰레드의 `interrupt()`가 호출되었는지 확인하는데 사용할 수 있다. 하지만, `interrupted()`와 달리 `isInterrupted()`는 쓰레드의 `interrupted` 상태를 `false`로 초기화하지 않는다.

| 메서드                       | 설명                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| void interrupt()             | 쓰레드의 interrupted 상태를 false에서 true로 변경한다.       |
| boolean isInterrupted()      | 쓰레드의 interrupted 상태를 반환한다.                        |
| static boolean interrupted() | 현재 쓰레드의 interrupted 상태를 반환하고, false로 변경한다. |
