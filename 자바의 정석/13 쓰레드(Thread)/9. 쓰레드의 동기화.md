# 목차

- [9.1 synchronized를 이용한 동기화](#91-synchronized를-이용한-동기화)
- [9.2 wait()과 notify()](#92-wait과-notify)
- [9.3 Lock과 Condition을 이용한 동기화](#93-Lock과-Condition을-이용한-동기화)
- [9.4 volatile](#94-volatile)
- [9.5 fork & join 프레임웍](#95-fork--join-프레임웍)

# 9. 쓰레드의 동기화

싱글쓰레드 프로세스의 경우 프로세스 내에서 단 하나의 쓰레드로 작업하기 때문에 프로세스의 자원을 가지고 작업하는데 특별한 문제가 없다. 하지만, 멀티쓰레드 프로세스의 경우 여러 쓰레드가 같은 프로세스 내의 자원을 공유해서 작업하기 때문에 서로의 작업에 영향을 주게 된다.

만약 쓰레드A가 작업하던 도중, 다른 쓰레드B에게 제어권이 넘어갔을 때, 쓰레드B가 쓰레드A가 작업하던 공유데이터를 변경하였다면, 쓰레드A가 제어권을 받아서 나머지 작업을 마쳤을 때 의도했던 것과는 다른 결과를 얻을 수 있다.

이러한 상황을 방지하기 위하여 도입된 개념이 바로 `임계 영역(critical section)`과 `잠금(락, lock)`이다.

공유 데이터를 사용하는 코드 영역을 임계 영역으로 지정해놓고, 공유 데이터(객체)가 가지고 있는 `lock`을 획득한 단 하나의 쓰레드만 이 영역 내의 코드를 수행할 수 있게 한다. 그리고 해당 쓰레드가 모든 코드를 수행하고 `lock`을 반납해야만 다른 쓰레드가 `lock`을 획득하여 임계 영역의 코드를 수행할 수 있게 된다.

이처럼 한 쓰레드가 진행 중인 작업을 다른 쓰레드가 간섭하지 못하도록 하는 것을 `쓰레드의 동기화(synchronization)`라고 한다. 자바에서는 `synchronized` 블럭을 이용해서 쓰레드의 동기화를 지원했지만, `JDK 1.5`부터는 `java.util.concurrent.locks`와 `java.util.concurrent.atomic` 패키지를 통해 다양한 방식으로 동기화를 구현할 수 있도록 지원하고 있다.

## 9.1 synchronized를 이용한 동기화

`synchronized` 키워드를 이용한 동기화에 대해 알아보자. 이 키워드는 임계 영역을 설정하는데 사용된다.

```Java
// 1. 메서드 전체를 임계 영역으로 지정
public synchronized void calcSum() {
    // ...
}

// 2. 특정한 영역을 임계 영역으로 지정
synchronized (객체의 참조변수) {
    // ...
}
```

첫 번째 방법은 메서드 앞에 `synchronized`를 붙이는 것이다. 이렇게 하면 메서드 전체가 임계 영역으로 설정된다. 쓰레드는 `synchronized` 메서드가 호출된 시점부터 해당 메서드가 포함된 객체의 `lock`을 얻어 작업을 수행하다가 메서드가 종료되면 `lock`을 반환한다.

두 번째 방법은 메서드 내의 코드 일부를 블럭`{}`으로 감싸고 블럭 앞에 `synchronized(참조변수)`를 붙이는 것이다. 이 때 참조 변수는 락을 걸고자 하는 객체를 참조하는 것이어야 한다. 이러한 블럭을 `synchronized` 블럭이라고 하며, 이 블럭의 영역 안으로 들어가면서부터는 쓰레드를 지정된 객체의 `lock`을 얻게 되고, 이 블럭을 벗어나면 `lock`을 반환한다.

두 방법 모두 `lock`의 획득과 반납이 자동으로 이뤄지므로 개발자가 할 일은 임계 영역만 설정해주면 된다. 임계 영역은 멀티쓰레드 프로그램의 성능을 좌우하기 때문에 가능하면 메서드 전체에 락을 거는 것보다 `synchronized` 블럭으로 임계 영역을 최소화해서 보다 효율적인 프로그램이 되도록 개발해야 한다.

## 9.2 wait()과 notify()

`synchronized`로 동기화해서 공유 데이터를 보호하는 것도 좋지만, 특정 쓰레드가 객체의 락을 오랜 시간을 보내지 않도록 하는 것도 중요하다. 이러한 상황을 개선하기 위하여 고안된 것이 바로 `wait()`와 `notify()`이다.

동기화된 임계 영역의 코드를 수행하다가 작업을 더 이상 진행할 상황이 아니면, 일단 `wait()`를 호출하여 쓰레드가 락을 반납하고 기다리게 한다. 이 때 다른 쓰레드는 락을 얻어 해당 객체에 대한 작업을 수행하게 된다. 나중에 다시 작업을 수행할 수 있는 상황이 되면 `notify()`를 호출해서 작업을 중단했던 쓰레드가 다시 락을 얻어 작업을 진행할 수 있게 된다.

다만, 오래 기다린 쓰레드가 락을 받는다는 보장은 없다. `wait()`이 호출되면, 실행 중인 쓰레드는 해당 객체의 대기실(waiting pool)에서 통지를 기다린다. `notify()`가 호출되면, 해당 객체의 대기실에 있던 모든 쓰레드 중에서 임의의 쓰레드만 통지를 받는다. `notifyAll()`은 기다리고 있는 모든 쓰레드에게 통보를 하지만, 그래도 `lock`을 받을 수 있는 쓰레드는 하나 뿐이다.

`wait()`과 `notify()`는 특정 객체에 대한 것이므로 `Object` 클래스에 정의되어 있다.

```Java
/*
- Object에 정의되어 있다.
- 동기화 블럭내에서만 사용할 수 있다.
- 보다 효율적인 동기화를 가능하게 한다.
*/
void wait()
void wait(long timeout)
void wait(long timeout, int nanos)
void notify()
void notifyAll()
```

매개변수가 없는 `wait()`은 `notify()` 또는 `notifyALl()`이 호출될 때까지 기다리지만, 매개변수가 있는 `wait()`은 지정된 시간동안만 기다린다. 따라서, 지정된 시간이 지난 후에는 자동으로 `notify()`가 호출되는 것과 같다.

그리고 `waiting pool`은 객체마다 존재하는 것이므로 `notifyAll()`이 호출된다고 해서 모든 객체의 `waiting pool`에 있는 쓰레드가 깨워지는 것은 아니다.

### 기아 현상과 경쟁 상태

특정 쓰레드가 계속 통지를 받지 못하고 오랫동안 기다리게 되는 현상을 `기아(starvation) 현상`이라고 한다. 이러한 현상을 막으려면 `notify()` 대신 `notifyAll()`을 사용해야 한다. 일단 모든 쓰레드에게 통지를 하면, 통지를 받아야 하는 쓰레드는 결국 `lock`을 받아서 작업을 진행할 수 있기 때문이다.

하지만, `notifyAll()`로 통지가 필요한 쓰레드의 `기아현상`은 막았지만, 불필요한 쓰레드까지 통지를 받아서 `lock`을 얻기 위해 경쟁하게 된다. 이처럼 여러 쓰레드가 `lock`을 얻기 위해 서로 경쟁하는 것을 `경쟁 상태(race condition)`라고 하는데, 이 상태를 개선하기 위해서는 쓰레드들을 구별해서 통지하는 것이 필요하다. `Lock`과 `Condition`을 이용하면, `wait()`, `notify()`로는 불가능한 선별적인 통지가 가능하다.

## 9.3 Lock과 Condition을 이용한 동기화

## 9.4 volatile

## 9.5 fork & join 프레임웍
