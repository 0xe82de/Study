# 목차

- [1.1 지네릭스란?](#11-지네릭스란)
- [1.2 지네릭 클래스의 선언](#12-지네릭-클래스의-선언)
- [1.3 지네릭 클래스의 객체 생성과 사용](#13-지네릭-클래스의-객체-생성과-사용)
- [1.4 제한된 지네릭 클래스](#14-제한된-지네릭-클래스)
- [1.5 와일드 카드](#15-와일드-카드)
- [1.6 지네릭 메서드](#16-지네릭-메서드)
- [1.7 지네릭 타입의 형변환](#17-지네릭-타입의-형변환)
- [1.7 지네릭 타입의 제거](#17-지네릭-타입의-제거)

# 1. 지네릭스(Generics)

## 1.1 지네릭스란?

`지네릭스`는 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일 시의 타입 체크(compile-time type check)를 해주는 기능이다. 객체의 타입을 컴파일 시에 체크하기 때문에 객체의 타입 안정성을 높이고 형변환의 번거로움이 줄어든다.

타입 안정성을 높임으로써 의도하지 않은 타입의 객체가 저장되는 것을 방지하고, 저장된 객체를 가져올 때 원래의 타입과 다른 타입으로 잘못 형변환되는 오류를 줄여준다.

### 지네릭스의 장점

1. 타입 안정성을 제공한다.
2. 타입체크와 형변환을 생략할 수 있으므로 코드가 간결해 진다.

## 1.2 지네릭 클래스의 선언

지네릭 타입으로 클래스를 선언하는 방법은 다음과 같다.

```Java
// 지네릭 미사용
class Box {
    Object item;
    void setItem(Object item) {
        this.item = item;
    }
    Object getItem() {
        return item;
    }
}

// 지네릭 사용
class Box<T> { // 지네릭 타입 T를 선언
    T item;
    void setItem(T item) {
        this.item = item;
    }
    T getItem( {
        return item;
    })
}
```

위의 코드에서 사용된 `T`를 `타입 변수(type vaiable)`라고 하며 `Type`의 첫 글자에서 따온 것이다.

타입 변수는 `T`가 아닌 다른 것을 사용해도 되는데, `ArrayList<E>`의 경우 타입 변수 `E`는 `Element(요소)`의 첫 글자를 따서 사용할 수 있다. 또한, `Map<K, V>`와 같이 타입 변수를 여러개 사용할 수 있는데, `K`는 `Key(키)`를 의미하고, `V`는 `Value(값)`을 의미한다.

무조건 `T`를 사용하기보다 상황에 맞는 문자를 선택해서 사용하면 된다. 기호의 종류만 다를 뿐 `임의의 참조형 타입`을 의미한다는 것은 모두 같다.

지네릭 클래스의 `Box` 클래스의 객체를 생성할 때는 다음과 같이 참조변수와 생성자에 타입 `T` 대신에 사용할 실제 타입을 지정해줘야 한다.

```Java
Box<String> box = new Box<String>(); // 타입 T 대신에 실제 타입을 지정한다.
box.setItem(new Object()); // Error. 위쪽 코드에서 String으로 지정하였으므로, String 이외의 타입은 불가하다.
box.setItem("ABC"); // Good. String 타입이므로 가능하다.
String item = box.getItem(); // 형변환이 필요없다.
```

지네릭이 도입되기 이전의 코드와 호환을 위해 지네릭 클래스임에도 불구하고 예전의 방식으로 객체를 생성하는 것이 허용된다.

```Java
Box box = new Box(); // T는 Object로 간주된다.
box.setItem("ABC"); // 경고. unchecked or unsafe operation
box.setItem(new Object()); // 경고. unchecked or unsafe operation

// 아래와 같이 변수 T에 Object 타입을 지정하면, 경고는 발생하지 않는다.
Box<Object> box = new Box<Object>();
box.setItem("ABC");
box.setItem(new Object());
```

### 지네릭스의 용어

```java
class Box<T> { }
```

위와 같이 지네릭 클래스 `Box`가 선언되어 있을 때 용어는 아래와 같다.

| 용어   | 설명                                              |
| ------ | ------------------------------------------------- |
| Box<T> | 지네릭 클래스, 'T의 Box' 또는 'T Box'라고 읽는다. |
| T      | 타입 변수 또는 타입 매개변수.(T는 타입 문자)      |
| Box    | 원시 타입(raw type)                               |

타입 문자 `T`는 지네릭 클래스 `Box<T>`의 타입 변수 또는 타입 매개변수라고 하는데, 메서드의 매개변수와 비슷한 면이 있기 때문이다. 아래와 같이 타입 매개변수에 타입을 지정하는 것을 `지네릭 타입 호출`이라고 하고, 지정된 타입 `String`을 `매개변수화된 타입(parameterized type)`이라고 한다. 매개변수화된 타입이라는 용어가 길기 때문에 `대입된 타입`이라는 용어를 사용하겠다(자바의 정석).

```java
Box<String> b = new Box<String>();
```

예를 들어, `Box<String>`과 `Box<Integer>`는 지네릭 클래스 `Box<T>`에 서로 다른 타입을 대입하여 호출한 것일 뿐이다. 마치 `Math.max(3, 5)`와 `Math.max(6, 3)`가 서로 다른 메서드를 호출하는 것이 아닌 것과 같다.

### 지네릭스의 제한

지네릭 클래스 `Box`의 객체를 생성할 때, 객체별로 타입을 다르게 지정하는 것은 가능하다. 하지만, 모든 객체에 대해 동일하게 동작해야 하는 `static` 멤버에 타입 변수 `T`를 사용할 수 없다. `T`는 인스턴스 변수로 간주되기 때문이며, `static` 멤버는 인스턴스 변수를 참조할 수 없다.

```java
class Box<T> {
    static T item; // Error.
    static int compare(T t1, T t2) { // Error.
        //...
    }
}
```

그리고 지네릭 타입의 배열을 생성하는 것도 허용되지 않는다. 지네릭 배열 타입의 참조변수를 선언하는 것은 가능하지만 `new T[10]`과 같이 배열을 생성하는 것은 안 된다.

```java
class Box<T> {
    T[] itemArr; // Good. T 타입의 배열을 위한 참조변수
    // ...
    T[] toArray() {
        T[] tmpArr = new T[itemArr.length]; // Error. 지네릭 배열 생성불가
        // ...
        return tmpArr;
    }
}
```

지네릭 배열을 생성할 수 없는 이유는 `new` 연산자의 특성 때문이다. `new` 연산자는 컴파일 시점에 타입 `T`가 뭔지 정확히 알아야 하는데, 컴파일 시점에는 `T`가 어떤 타입이 될지 전혀 알 수 없다. 같은 이유로 `instanceof` 연산자도 `T`를 피연산자로 사용할 수 없다. 지네릭 배열을 생성해야할 필요가 있을 때는 `new` 연산자 대신 `Reflection API`의 `newInstance()`와 같이 동적으로 객체를 생성하는 메서드로 배열을 생성하거나, `Object` 배열을 생성해서 복사하고 `T[]`로 형변환하는 방법 등이 사용하면 된다.

## 1.3 지네릭 클래스의 객체 생성과 사용

## 1.4 제한된 지네릭 클래스

## 1.5 와일드 카드

## 1.6 지네릭 메서드

## 1.7 지네릭 타입의 형변환

## 1.7 지네릭 타입의 제거
