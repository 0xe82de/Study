# 5. 형변환

## 목차

- [5.1 형변환(캐스팅, casting)이란?](#51-형변환캐스팅-casting이란)
- [5.2 형변환 방법](#52-형변환-방법)
- [5.3 정수형 간의 형변환](#53-정수형-간의-형변환)
- [5.4 실수형 간의 형변환](#54-실수형-간의-형변환)
- [5.5 정수형과 실수형간의 형변환](#55-정수형과-실수형간의-형변환)
- [5.6 자동 형변환](#56-자동-형변환)

## 5.1 형변환(캐스팅, casting)이란?

프로그래밍을 하다 보면 서로 다른 타입간의 연산을 수행해야 하는 경우가 있다.

변수나 리터럴의 타입을 다른 타입으로 변환하는 것을 `형변환(casting)`이라고 한다.

## 5.2 형변환 방법

형변환의 방법은 아주 간단한데, 형변환하고자 하는 변수나 리터럴의 앞에 변환하고자 하는 타입을 괄호와 함께 붙여주면 된다.

```
(타입)피연산자
```

여기에 사용되는 괄호`()`는 `캐스트 연산자` 또는 `형변환 연산자`라고 하며, 형변환을 `캐스팅(casting)`이라고도 한다.

```Java
double d = 12.3;
int i = (int)d; // 변수 i에 12가 저장된다. 변수 d의 값은 12.3으로 유지된다.
```

기본형(primitive type)에서 `boolean`을 제외한 나머지 타입들은 서로 형변환이 가능하다. 그리고 기본형과 참조형간의 형변환은 불가능하다.

|     변환     |   수식    | 결과  |
| :----------: | :-------: | :---: |
| int -> char  | (char)65  |  'A'  |
| char -> int  | (int)'A'  |  65   |
| float -> int | (int)1.6f |   1   |
| int -> float | (float)10 | 10.0f |

## 5.3 정수형 간의 형변환

큰 타입에서 작은 타입으로의 형변환을 할 때 값의 손실이 발생할 수 있다.

예를 들어서 `int` 타입의 값 `300`을 `byte` 타입으로 형변환하면 값 `44`가 저장된다. 왜냐하면 `int` 타입의 값 `300`을 2진수로 표현하면 `1 0010 1100`인데 `byte` 타입은 최대 8 bit까지 가질 수 있기 때문이다. 따라서, 2진수로 표현되었을 때 값 `0010 1100`이 저장되고, 이는 10진수 `44`이다.

반대로 작은 타입에서 큰 타입으로의 형변환에서는 값의 손실이 발생하지 않는다. 남은 공간은 양수의 경우 `0`으로 채워지고 음수의 경우 `1`로 채워진다.

## 5.4 실수형 간의 형변환

실수형에서도 정수형처럼 작은 타입에서 큰 타입으로 형변환하는 경우, 빈 공간을 `0`으로 채운다.

반대로 큰 타입인 `double` 타입에서 작은 타입인 `float` 타입으로 형변환하는 경우 값의 손실이 발생할 수 있다. 정수형과 마찬가지로 `double` 타입의 표현범위가 더 넓기 때문이다.

## 5.5 정수형과 실수형간의 형변환

정수형과 실수형은 저장형식이 완전히 다르므로 정수형간의 변환처럼 간단히 값을 채우고 자르는 식으로 할 수 없다.

### 정수형을 실수형으로 변환

정수는 소수점 이하의 값이 없으므로 비교적 실수형으로의 형변환이 간단하다. 정수를 2진수로 변환하고 정규화를 거쳐 실수형의 저장형식으로 저장된다.

실수형은 정수형보다 훨씬 큰 저장범위를 가지므로 정수형을 실수형으로 형변환하는 것에는 별 무리가 없다.

한 가지 주의할 점은 실수형의 정밀도의 제한으로 인한 오차가 발생할 수 있다는 점이다. 예를 들어 `int` 타입의 최대값은 약 20억으로 최대 10자리의 정밀도를 요구한다. `float` 타입은 7자리의 정밀도를 제공하는데, 만약 `int` 타입의 값 약 20억을 `float` 타입으로 형변환하면 오차가 발생할 수 있다. 그래서 10진수로 8자리 이상의 값을 실수형으로 형변환할 때는 `float` 타입이 아니라 `double` 타입으로 형변환해야 오차가 발생하지 않는다.

### 실수형을 정수형으로 변환

실수형을 정수형으로 형변환하면, 실수형의 소수점 이하 값은 버려진다. 정수형의 표현형식으로 소수점 이하의 값은 표현할 수 없기 때문이다. 예를 들어 `float` 타입의 리터럴 `9.1234567f`를 `int` 타입으로 형변환하면 `9`가 된다.

만약 실수의 소수점을 버리고 남은 정수가 정수형의 저장범위를 넘는 경우에는 오버플로우가 발생한 결과를 얻는다.

## 5.6 자동 형변환

서로 다른 타입간의 대입이나 연산을 할 때, 형변환으로 타입을 맞춰주는 것이 원칙이다. 하지만, 경우에 따라 형변환을 생략할 수 있다.

```Java
float f = 5678; // 형변환의 생략. float f = (float)5678;과 같다.
```

위의 코드에서 우변은 `int` 타입의 리터럴이고, 이 값을 저장하려는 변수의 타입은 `float`이다. 서로 타입이 다르기에 형변환이 필요하지만 편의상 생략할 수 있다. `float` 타입의 저장범위가 `int` 타입의 저장범위보다 넓기 때문이다.

```Java
byte b = 2000; // Error. byte의 범위 (-128 ~ 127)를 넘는 값을 저장.
```

위의 코드에서는 `incompatible types: possible lossy conversion from int to byte` 에러가 발생한다. 왜냐하면 `byte` 타입보다 넓은 저장범위를 가지는 `int` 타입의 값을 저장하기 때문이다. 하지만, 다음과 같이 `명시적`으로 형변환을 해주면 에러는 발생하지 않지만 값의 손실이 발생할 수 있다.

```java
byte b = (byte)2000; // Good. 명시적 형변환. 에러가 발생하지 않지만, 값의 손실이 발생할 수 있다.
```

서로 다른 타입간의 덧셈에서는 두 타입 중 표현범위가 더 넓은 타입으로 자동적으로 형변환이 이뤄지고 연산이 수행된다.

```Java
int i = 5;
double d = 2.0 + i; // 7.0이 저장된다. double d = 2.0 + (double)i;와 같다.
```

위와 같이 자동적으로 발생하는 형변환을 `산술 변환`이라고 한다.

### 자동 형변환의 규칙

형변환을 생략하면 컴파일러가 알아서 형변환을 수행하는데, 다음과 같은 기준으로 형변환을 수행한다.

```
기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환한다.
```

표현범위가 좁은 타입에서 넓은 타입으로 형변환하는 경우에는 값 손실이 발생하지 않기 때문에 두 타입 중에서 표현범위가 더 넓은 쪽으로 형변환된다.

- byte -> short -> int -> long -> float -> double
- char -> int

위의 순서는 자동 형변환이 가능한 순서이다. 왼쪽에서 오른쪽으로 형변환할 때는 형변환의 생략이 가능하며 반대 방향의 경우 반드시 형변환 연산자를 사용해야 한다.

실수형은 정수형과 값을 표현하는 방식이 다르기 때문에 같은 크기일지라도 실수형이 정수형보다 훨씬 더 큰 표현범위를 갖는다. 따라서 `float` 타입과 `double` 타입이 같은 크기인 `int` 타입과 `long` 타입보다 오른쪽에 위치하는 것이다.

`char` 타입과 `short` 타입은 둘 다 2 byte의 크기로 크기가 같지만, `char` 타입의 범위는 `0 ~ 2^16 -1(0 ~ 65535)`이고 `short` 타입의 범위는 `-2^15 ~ 2^15-1(-32768 ~ 32767)`이므로 서로 범위가 달라서 둘 중 어느쪽으로의 형변환도 값 손실이 발생할 수 있다. 따라서 두 타입간에는 자동 형변환이 불가능하다.
