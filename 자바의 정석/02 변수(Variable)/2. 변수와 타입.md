# 2. 변수와 타입

## 목차

- [2.1 기본형(primitive type)](#21-기본형primitive-type)
- [2.2 상수와 리터럴(constant & literal)](#22-상수와-리터럴constant--literal)
- [2.3 형식화된 출력 - printf()](#23-형식화된-출력---printf)

우리가 주로 사용하는 값(data)의 종류(type)는 크게 '문자와 숫자'로 나눌 수 있으며, 숫자는 다시 '정수와 실수'로 나눌 수 있다.

이러한 값(data)의 종류(type)에 따라 값이 저장될 공간이 크기와 저장형식을 정의한 것이 자료형(data type)이다.

### 기본형과 참조형

자료형은 크게 '기본형'과 '참조형' 두 가지로 나눌 수 있는데, **기본형 변수는 실제 값(data)을 저장**하는 반면, **참조형 변수는** 어떤 값이 저장되어 있는 **주소(memory address)를 값으로 갖는다.**

자바는 C언어와 달리 참조형 변수 간의 연산을 할 수 없으므로 실제 연산에 사용되는 것은 모두 기본형 변수이다.

### 기본형(primitive type)

- 논리형 : `boolean`
- 문자형 : `char`
- 정수형 : `byte`, `short`, `int`, `long`
- 실수형 : `float`, `double`
- 총 8개

### 참조형(reference type)

- 객체의 주소를 저장한다.
- 8개의 기본형을 제외한 나머지 타입

참조형 변수(또는 참조변수)를 선언할 때는 변수의 타입으로 클래스의 이름을 사용하므로 클래스의 이름이 참조변수의 타입이 된다.

그래서 새로운 클래스를 작성한다는 것은 새로운 참조형을 추가하는 셈이다.

다음은 참조변수를 선언하는 방법이다. 기본형 변수와 같이 변수이름 앞에 타입을 적어주는데 참조변수의 타입은 클래스의 이름이다.

```Java
클래스이름 변수이름; // 변수의 타입이 기본형이 아닌 것들은 모두 참조변수이다.
```

다음은 `Date` 클래스 타입의 참조변수 `today`를 선언한 것이다. 참조변수는 null 또는 객체의 주소를 값으로 갖으며 참조변수의 초기화는 다음과 같이 한다.

```Java
Date today = new Date(); // Date객체를 생성해서, 그 주소를 today에 저장
```

객체를 생성하는 연산자 `new`의 결과는 생성된 객체의 주소이다. 이제 참조변수 `today`를 통해서 생성된 객체를 사용할 수 있게 된다.

## 2.1 기본형(primitive type)

기본형에는 모두 8개의 타입(자료형)이 있으며, 크게 논리형, 문자형, 정수형, 실수형으로 구분된다.

1. 논리형

   - `boolean`
   - `true`와 `false` 중 하나를 값으로 갖으며, 조건식과 논리적 연산에 사용된다.

2. 문자형
   - `char`
   - 문자를 저장하는데 사용되며, 변수에 하나의 문자만 저장할 수 있다.
3. 정수형
   - `byte`, `short`, **`int`**, `long`
   - 정수를 저장하는데 사용되며, 주로 `int`가 사용된다.
   - `byte`는 이진 데이터를 다룰 때 사용되며, `short`는 `C언어`와의 호환을 위해서 추가되었다.
4. 실수형
   - `float`, **`double`**
   - 실수를 저장하는데 사용되며, 주로 `double`이 사용된다.

문자형인 `char`는 문자를 내부적으로 정수(유니코드)로 저장하기 때문에 정수형과 별반 다르지 않으며, 정수형 또는 실수형과 연산도 가능하다.

반면에 `boolean`은 다른 기본형과의 연산이 불가능하다. 즉, `boolean`을 제외한 나머지 7개의 기본형은 서로 연산과 변환이 가능하다.

정수는 가장 많이 사용되므로 타입을 4가지나 제공한다.

각 타입마다 저장할 수 있는 값의 범위가 다르므로 저장할 값의 범위에 맞는 타입을 선택하면 되지만, **일반적으로 int를 많이 사용한다.**

**왜냐하면, int는 CPU가 가장 효율적으로 처리할 수 있는 타입이기 때문이다.** 효율적인 실행보다 메모리를 절약하려면, `byte`나 `short`를 선택하자.

### 기본형의 종류와 크기

| 자료형  | 크기 (bit) | 크기 (byte) |
| ------- | ---------- | ----------- |
| boolean | 8          | 1           |
| char    | 16         | 2           |
| byte    | 8          | 1           |
| short   | 16         | 2           |
| int     | 32         | 4           |
| long    | 64         | 8           |
| float   | 32         | 4           |
| double  | 64         | 8           |

7~9자리의 수를 계산할 때는 넉넉하게 `long` 타입(약 19자리)으로 변수를 선언하는 것이 좋다.

실수형은 정수형과 저장형식이 달라서 같은 크기라도 훨씬 큰 값을 표현할 수 있으나 오차가 발생할 수 있다는 단점이 있다.

그래서 정밀도(precision)가 중요한데, 정밀도가 높을수록 발생할 수 있는 오차의 범위가 줄어든다.

아래의 표를 보면 `float`의 정밀도는 7자리인데, 이 것은 10진수로 7자리의 수를 오차없이 저장할 수 있다는 뜻이다.

### 실수형의 범위와 정밀도

| 자료형 | 저장 가능한 값의 범위                       | 정밀도 | 크기 (bit) | 크기 ( byte) |
| ------ | ------------------------------------------- | ------ | ---------- | ------------ |
| float  | 1.4E-45 ~ 3.4E38 (1.4x10^-45~3.4x10^38)     | 7자리  | 32         | 4            |
| double | 4.9E-324 ~ 1.8E308 (4.9x10^-324~1.8x10^308) | 15자리 | 64         | 8            |

`float`는 약 +-10^36과 같이 큰 값을 저장할 수 있지만, 정밀도가 7자리 밖에 되지 않으므로 보다 높은 정밀도가 필요한 경우에는 변수의 타입으로 `double`을 선택해야 한다.

## 2.2 상수와 리터럴(constant & literal)

'상수(constant)'는 변수와 달리 한 번 값을 저장하면 다른 값으로 변경할 수 없다.

상수를 선언하는 방법은 변수의 타입 앞에 `final`을 붙여주기만 하면 된다.

```Java
final int MAX_POWER = 100;
```

상수는 반드시 선언과 동시에 초기화해야 한다.

```Java
final int MAX_POWER;        // Error. 상수는 선언과 동시에 초기화해야 한다.
// JDK 1.6부터 상수를 선언과 동시에 초기화하지 않아도 된다. 하지만 선언과 동시에 초기화하는 습관을 가지는 것이 좋다.
final int MAX_WEIGHT = 50;  // Good.
MAX_WEIGHT = 100;           // Error. 상수의 값은 변경할 수 없다.
```

상수의 이름은 대문자로 하는 것이 좋다. 여러 단어로 이루어진 경우 `_`로 구분한다.

### 리터럴(literal)

프로그래밍에서 상수를 "값을 한 번 저장하면 변경할 수 없는 저장공간"으로 정의하였기 때문에, 이와 구분하기 위하여 실제 상수값을 다른 이름으로 불러야 했다.

그래서 리터럴이라는 용어를 사용한다.

| 구분            | 설명                            |
| :-------------- | :------------------------------ |
| 변수(variable)  | 하나의 값을 저장하기 위한 공간  |
| 상수(constant)  | 값을 한번만 저장할 수 있는 공간 |
| 리터럴(literal) | 그 자체로 값을 의미하는 것      |

```Java
int year = 2021;
final int MAX_POWER = 200;
// year -> 변수
// MAX_POWER -> 상수
// 2021, 200 -> 리터럴
```

### 상수가 필요한 이유

리터럴만 사용하지 않고, 상수를 사용하는 이유는 뭘까?

```Java
int triangleArea = (30 * 10) / 2; // 삼각형의 면적
int rectangleArea = 30 * 10; // 사각형의 면적을 구하는 공식
```

위의 코드에는 삼각형과 사각형의 면적을 구하고 변수에 저장한다. 간단한 공식이기에 굳이 상수를 사용할 필요가 없어보이지만, 복잡한 공식이라면 얘기가 다르다.

```Java
final int WIDTH = 30; // 폭
final int HEIGHT = 10; // 높이

int triangleArea = (WIDTH * HEIGHT) / 2; // 삼각형의 면적
int rectangleArea = WIDTH * HEIGHT; // 사각형의 면적을 구하는 공식
```

위와 같이 상수를 이용해서 코드를 작성하면 코드의 의미가 명확해질 뿐만 아니라, 다른 값으로 계산할 때(폭과 높이가 변경될 때) 여러 곳을 수정할 필요 없이 상수의 초기화만 다른 값으로 하면 된다.

이와 같이 리터럴에 "의미를 가지는 이름"을 붙여서 코드의 이해와 수정을 쉽게 만든다.

### 리터럴의 타입과 접미사

변수에 타입이 있듯이 리터럴에도 타입이 있다. 변수의 타입은 저장될 "값의 타입(리터럴의 타입)"에 의해 결정된다.

|  종류  | 리터럴                       | 접미사 |
| :----: | ---------------------------- | ------ |
| 논리형 | false, true                  | 없음   |
| 정수형 | 123, 0b0101, 077, 0xFF, 100L | L      |
| 실수형 | 3.14, 3.0e8, 1.4f, 0x1.0p-1  | f, d   |
| 문자형 | 'A', '1', '\n'               | 없음   |
| 문자열 | "ABC", "123", "A", "true"    | 없음   |

정수형과 실수형에는 여러 타입이 존재하므로 접미사를 붙여서 타입을 구분한다.

정수형의 경우 `long` 타입의 접미사 `l` 또는 `L`을 붙이고, 접미사가 없으면 int 타입의 리터럴이다.

`byte`와 `short` 타입의 리터럴은 별도로 존재하지 않으며 `byte`와 `short` 타입의 변수에 값을 저장할 때는 `int` 타입의 리터럴을 사용한다.

`10진수` 외에도 `2진수`, `8진수`, `16진수`로 표현된 리터럴을 변수에 저장할 수 있다. `2진수`, `8진수`, `16진수`를 표현하기 위해 각각 리터럴 앖에 접두사 `0b`, `0x`, `0`을 붙인다.

```Java
int octNum = 010; // 8진수 10, 10진수 8
int hexNum = 0x10; // 16진수 10, 10진수로 16
int binNum = 0b10; // 2진수 10, 10진수로 2
```

그리고 JDK 1.7부터 정수형의 리터럴의 중간에 구분자 `_`를 넣을 수 있게 되어서 큰 숫자를 편하게 사용할 수 있게 되었다.

```Java
long big = 100_000_000_000L; // long big = 1000000000000L;
long hex = 0xFFFF_FFFF_FFFF_FFFFL; // long hex = 0xFFFFFFFFFFFFFFFF;
```

실수형에서는 `float` 타입의 리터럴에 접미사 `f` 또는 `F`를 붙이고, double 타입의 리터럴에는 접미사 `d` 또는 `D`를 붙인다.

```Java
float pi = 3.14f; // 접미사 f 대신 F를 사용해도 된다.
double rate = 1.006d; // 접미사 d 대신 D를 사용해도 되며, 생략해도 된다.
```

정수형에서 `int`가 기본 자료형인 것처럼 실수형에서는 `double`이 기본 자료형이므로 접미사 `d`는 생략할 수 있다.

```Java
float pi = 3.14; // Error. float 타입 변수에 double 타입 리터럴 저장
double rate = 1.006; // Good. double 타입 변수에 double 타입 리터럴 저장. 접미사 d는 생략되었음.
```

위의 코드에서 `3.14`는 접미사가 붙지 않았기 때문에 `double` 타입의 리터럴로 간주된다. 그래서 `3.14`가 `float` 타입의 범위에 속한 값임에도 불구하고 컴파일 에러가 발생한다. 에러를 피하려면 `float` 타입의 접미사 `f` 또는 `F`를 붙여야 한다.

리터럴에 소수점이나 10의 제곱을 나타내는 기호 `E` 또는 `e`, 그리고 접미사 `f`, `F`, `d`, `D`를 포함하고 있으면 실수형 리터럴로 간주된다.

| 자료형 | 실수형 리터럴 | 다른 형태의 동등한 표현 |
| :----: | :-----------: | :---------------------: |
| double |      10.      |          10.0           |
| double |      .10      |          0.10           |
| float  |      10f      |          10.0f          |
| float  |    3.14e3f    |         3140.0f         |
| double |      1e1      |          10.0           |
| double |     1e-3      |          0.001          |

참고로 기호 `p`를 사용해서 실수 리터럴을 `16진 지수형태`로 표현할 수 있다. `p`는 2의 제곱을 의미하며, `p`의 왼쪽에는 16진수를 적고 오른쪽에는 지수를 10진수 정수로 적는다.

`p`는 대소문자 모두 가능하며, `p`가 포함된 리터럴은 실수형이다.

```Java
double d1 = 0x1p1 = (1 x 16^0) x 2^1 = 1.0 x 2 = 2.0
double d2 = 0x0.2p-1 = (2 x 16^-1) x 2^-1 = 0.125 x 0.5 = 0.0625
double d3 = 0x12p3 = (1 x 16^1 + 2 x 16^0) x 2^3 = (16 + 2) x 8 = 144.0
```

### 타입의 불일치

리터럴의 타입은 저장될 변수의 타입과 일치하는 것이 일반적이지만, 타입이 달라도 저장범위가 넓은 타입에 좁은 타입의 값을 저장하는 것은 가능하다.

```Java
int i = 'A'; // Good. 문자 'A'의 유니코드인 65가 변수 i에 저장된다.
long l = 123; // Good. 마찬가지로 long 타입이 범위가 int 타입의 범위보다 넓으므로 가능하다.
double d = 3.14f; // Good. 마찬가지로 double 타입의 범위가 float 타입의 범위보다 넓으므로 가능하다.
```

하지만 리터럴의 값이 변수의 타입의 범위를 넘어서거나, 리터럴의 타입이 변수의 타입보다 저장범위가 넓으면 컴파일 에러가 발생한다.

```Java
int i = 0x123456789; // Error. int 타입의 범위를 넘는 값을 저장하므로 에러가 발생한다.
float f = 3.14; // Error. float 타입보다 double 타입의 범위가 넓기 때문에 에러가 발생한다.
```

`byte`, `short` 타입의 리터럴은 따로 존재하지 않고 `int` 타입의 리터럴을 사용한다. 단, `byte`, `short` 타입의 변수가 저장할 수 있는 범위에 속해야 한다.

```Java
byte b = 65; // Good. byte 타입에 저장 가능한 범위의 int 타입의 리터럴을 저장한다.
short s = 0x1234; // Good. short 타입에 저장 가능한 범위의 int 타입의 리터럴을 저장한다.
```

### 문자 리터럴과 문자열 리터럴

'A'와 같이 작은 따옴표로 문자 하나를 감싼 것을 `문자 리터럴`이라고 한다. 두 문자 이상은 큰 따옴표로 감싸야 하며 `문자열 리터럴`이라고 한다.

`char` 타입의 변수는 단 하나의 문자만 저장할 수 있다. 따라서, 여러 문자(문자열)를 저장하기 위해서는 `String` 타입의 변수를 사용해야 한다.

문자열 리터럴은 `""`안에 아무런 문자도 넣지 않는 것을 허용한다. 이를 빈 문자열(empty string)이라고 한다.

그러나 문자 리터럴은 반드시 `''`안에 하나의 문자가 있어야 한다.

```Java
String str = ""; // Good. 빈 문자열
char ch = ''; // Error. ''안에 반드시 하나의 문자가 필요
char ch = ' '; // Good. 공백 문자(blank)이다.
```

원래 `String`은 클래스이므로 객체를 생성하는 연산자 `new`를 사용해야 하지만 위와 같은 표현도 허용한다.

```Java
String name = new String("Java"); // String 객체를 생성한다.
```

그리고 덧셈 연산자로 문자열을 결합할 수 있다.

```Java
String name = "J" + "ava"; // Java
String str = name + 11.0; // Java11.0
```

덧셈 연산자 `+`는 피연산자가 모두 숫자일 때는 두 수를 더한다.

하지만, 피연산자 중 어느 한 피연산자가 `String` 타입이라면, 나머지 피연산자를 `String`으로 변환한 다음 두 `String`을 결합한다.

덧셈 연산자는 왼쪽에서 오른쪽의 방향으로 연산을 수행하므로 결합순서에 따라 결과가 달라진다.
