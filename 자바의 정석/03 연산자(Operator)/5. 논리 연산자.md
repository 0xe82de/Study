# 목차

- [5.1 논리 연산자](#51-논리-연산자)
- [5.2 비트 연산자](#52-비트-연산자)

# 5. 논리 연산자

논리 연산자는 둘 이상의 조건을 `그리고(AND)`나 `또는(OR)`으로 연결하여 하나의 식으로 표현할 수 있게 해준다.

## 5.1 논리 연산자

논리 연산자는 피연산자로 `boolean` 타입 또는 `boolean` 타입의 값을 결과로 하는 조건식만을 허용한다.

| 연산자        | 설명                                                    |
| ------------- | ------------------------------------------------------- |
| \|\| (OR결합) | 피연산자 중 어느 한 쪽만 true이면 true를 결과로 얻는다. |
| && (AND결합)  | 피연산자 중 양쪽 모두 true이어야 true를 결과로 얻는다.  |

### 효율적인 연산(short circuit evaluation)

논리 연산자의 또 다른 특징은 효율적인 연산을 한다는 것이다. OR연산 `||`의 경우 왼쪽 피연산자가 `true`일 경우 오른쪽 피연산자의 값은 확인하지 않고, `true`를 반환한다.

AND연산 `&&`의 경우도 왼쪽 연산자가 `false`이면 오른쪽 연산자는 확인하지 않고 `false`를 반환한다.

### 논리 부정 연산자 !

논리 부정 연산자는 피연산자가 `true`이면 `false`를, `false`이면 `true`를 반환한다.

|   x   |  !x   |
| :---: | :---: |
| true  | false |
| false | true  |

이 연산자를 이용하면 전원 버튼과 같은 토글 기능을 논리적으로 구현할 수 있다.

논리 부정 연산자 `!`가 주로 사용되는 곳은 조건문과 반복문의 조건식이며, 이 연산자를 잘 사용하면 조건식이 보다 이해하기 쉬워진다. 예를 들어 "문자 ch는 소문자가 아니다"라는 조건을 아래와 같이 두 문장으로 나타낼 수 있지만 두 번째 문장이 더 이해하기 쉽다.

```Java
boolean isSmall1 = ch < 'a' || ch > 'z'
boolean isSmall2 = !('a' <= ch && ch <= 'z')
```

## 5.2 비트 연산자

비트 연산자는 피연산자를 비트단위로 논리 연산한다. 피연산자를 `2진수`로 표현했을 때의 각 자리를 아래의 규칙에 따라 연산을 수행한다. 피연산자로 실수는 허용하지 않으며, 정수(문자 포함)만 허용된다.

| 연산자        | 설명                                                                     |
| ------------- | ------------------------------------------------------------------------ |
| \| (OR연산자) | 피연산자 중 한 쪽의 값이 1이면, 1을 결과로 얻는다. 그 외에는 0을 얻는다. |
| & (AND연산자) | 피연산자 양 쪽이 모두 1이어야만 1을 결과로 얻는다. 그 외에는 0을 얻는다. |
| ^ (XOR연산자) | 피연산자의 값이 서로 다를 때만 1을 결과로 얻는다. 같을 때는 0을 얻는다.  |

|  x  |  y  | x \| y | x & y | x ^ y |
| :-: | :-: | :----: | :---: | :---: |
|  1  |  1  |   1    |   1   |   0   |
|  1  |  0  |   1    |   0   |   1   |
|  0  |  1  |   1    |   0   |   1   |
|  0  |  0  |   0    |   0   |   0   |

비트 연산자 `|`는 주로 특정 비트의 값을 변경할 때 사용한다. 아래와 같이 피연산자 `0xAB`의 마지막 4 bit를 `F`로 변경할 수 있다.

|         식         |                                 2진수 |       16진수        |
| :----------------: | ------------------------------------: | :-----------------: |
| 0xAB \| 0xF = 0xAF | 10101011<br>\| ) 00001111<br>10101111 | 0xAB<br>0xF<br>0xAF |

비트 연산자 `&`는 주로 특정 비트의 값을 뽑아낼 때 사용한다. 아래와 같이 피연산자의 마지막 4 bit가 어떤 값인지 알아낼 수 있다.

|        식        |                                2진수 |       16진수       |
| :--------------: | -----------------------------------: | :----------------: |
| 0xAB & 0xF = 0xB | 10101011<br>& ) 00001111<br>00001011 | 0xAB<br>0xF<br>0xB |

비트 연산자 `^`는 두 피연산자의 비트가 다를 때만 1이 된다.

|        식         |                                2진수 |       16진수        |
| :---------------: | -----------------------------------: | :-----------------: |
| 0xAB ^ 0xF = 0xA4 | 10101011<br>^ ) 00001111<br>10100100 | 0xAB<br>0xF<br>0xA4 |

### 비트 전환 연산자 ~

비트 전환 연사자 `~`는 피연산자를 2진수로 표현했을 때 0은 1로, 1은 0으로 바꾼다.

|  x  | ~x  |
| :-: | :-: |
|  1  |  0  |
|  0  |  1  |

비트 전환 연산자 `~`에 의해 비트가 전환되면 부호가 있는 타입의 피연산자는 부호가 반대로 변경된다. 즉, 피연산자의 `1의 보수`를 얻을 수 있는 것이다. 그래서 비트 전환 연산자 `~`를 1의 보수 연산자라고도 한다.

|            2진수            |      10진수       |
| :-------------------------: | :---------------: |
| 00001010<br> ↓ <br>11110101 | 10 <br> ↓<br> -11 |

양의 정수 p가 있을 때 p에 대한 음의 정수를 얻으려면 `~p+1`을 계산하면 된다. 반대로 음의 정수 m이 있을 때 m에 대한 양의 정수를 얻으려면 `~(n-1)`을 계산하면 된다. 물론 부호 연산자 `-`를 사용하면 간편하게 부호를 바꿀 수 있다.

피연산자의 타입이 `int` 타입보다 작으면 `int` 타입으로 자동 형변환되므로 연산결과는 32자리의 2진수이다.

### 쉬프트 연산자 << >>

쉬프트 연산자는 피연산자를 2진수로 표현하였을 때 각 자리를 오른쪽 또는 왼쪽으로 이동시키는 연산자이다.

예를 들어 `8 << 2`는 왼쪽 피연산자인 10진수 8의 2진수를 왼쪽으로 2자리 이동한다. 이 때 자리이동으로 저장범위를 벗어난 값들은 버려지고 빈자리는 0으로 채워진다.

|           2진수           |    10진수    |
| :-----------------------: | :----------: |
| 00001000<br>↓<br>00100000 | 8<br>↓<br>32 |
