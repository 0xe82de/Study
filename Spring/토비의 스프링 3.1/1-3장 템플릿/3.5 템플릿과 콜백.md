# Contents

- [3.5.1 템플릿/콜백의 동작원리](#351-템플릿콜백의-동작원리)
- [3.5.2 편리한 콜백의 재활용](#352-편리한-콜백의-재활용)
- [3.5.3 템플릿/콜백의 응용](#353-템플릿콜백의-응용)

# 3.5 템플릿과 콜백

지금까지의 `UserDao`, `StatementStrategy`, `JdbcContext`를 이용해 작성한 코드는 일종의 전략 패턴이 적용되었다고 볼 수 있다. 복잡하지만 바뀌지 않는 일정한 패턴을 갖는 작업 흐름이 존재하고 일부분만 바꿔서 사용해야 하는 경우에 적합한 구조다.

```java
public class JdbcContext {
    // ...
    public void workWithStatementStrategy(StatementStrategy stmt) throws SQLException {
        // PreparedStatement를 만드는 부분을 제외하고 바뀌지 않는 일정한 패턴을 갖는다.
        Connection c = null;
        PreparedStatement ps = null;

        try {
            c = dataSource.getConnection();
            ps = stmt.makePreparedStatement(c); // 자주 바뀌는 부분
            ps.executeUpdate();
        } catch (SQLException e) {
            throw e;
        } finally {
            if (ps != null) {
                try {
                    ps.close();
                } catch (SQLException e) {
                }
            }
            if (c != null) {
                try {
                    c.close();
                } catch (SQLException e) {
                }
            }
        }
    }
    // ...
}
```

전략 패턴이 적용된 위의 코드와 익명 내부 클래스를 활용하였는데, 이러하 방식을 스프링에서는 템플릿/콜백 패턴이라고 한다. 전략 패턴의 컨텍스트를 템플릿이라 하고, 익명 내부 클래스의 오브젝트를 콜백이라고 한다.

## 3.5.1 템플릿/콜백의 동작원리

템플릿은 고정된 작업 흐름을 가진 코드를 재사용한다는 의미에서 붙은 이름이며, 콜백은 템플릿 안에서 호출되는 것을 목적으로 만들어진 오브젝트를 의미한다.

### 템플릿/콜백의 특징

전략 패턴은 여러 개의 메서드를 가진 인터페이스를 사용할 수 있지만, 템플릿/콜백 패턴의 콜백은 보통 단일 메서드 인터페이스를 사용한다. 템플릿의 작업 흐름 중 특정 기능을 위해 한 번 호출되는 경우가 일반적이기 때문이다. 콜백은 일반적으로 하나의 메서드를 가진 인터페이스를 구현한 익명 내부 클래스로 만들어진다고 보면 된다.

콜백 인터페이스의 메서드에는 보통 파라미터가 있는데, 이를 통해 템플릿의 작업 중에 만들어지는 컨텍스트 정보를 전달받는다. `JdbcContext`의 템플릿인 `workWithStatementStrategy()` 메서드에서 생성한 `Connection` 오브젝트를 콜백의 메서드인 `makePreparedStatement()`를 실행할 때 파라미터로 전달한다.

```java
public void workWithStatementStrategy(StatementStrategy stmt) throws SQLException {
    Connection c = null;
    PreparedStatement ps = null;

    try {
        c = dataSource.getConnection();
        ps = stmt.makePreparedStatement(c); // Connection 오브젝트를  파라미터로 전달한다.
        ps.executeUpdate();
    } catch (SQLException e) {
    // ...
}
```

위의 코드에서 `Connection` 오브젝트를 전달하는 이유는 `PreparedStatement`를 만들기 위해 `Connection` 오브젝트가 사용되기 때문이다.

`UserDao`의 `add()` 메서드를 클라이언트, `JdbcContext`의 `workWithStatementStrategy` 메서드를 템플릿, `add()` 메서드 내의 익명 내부 클래스의 오브젝트를 콜백이라 할 수 있는데, 각각의 역할은 다음과 같다.

| 구분       | 역할                                                                                                                                                                  |
| ---------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 클라이언트 | 템플릿 안에서 실행될 로직을 담은 콜백 오브젝트를 만들고, 콜백이 참조할 정보를 제공한다. 만들어진 콜백은 클라이언트가 템플릿의 메서드를 호출할 때 파라미터로 전달된다. |
| 템플릿     | 정해진 작업 흐름을 따라 작업을 진행하다가 내부에서 생성한 참조정보를 가지고 콜백 오브젝트의 메서드를 호출한다.                                                        |
| 콜백       | 클라이언트 메서드에 있는 정보와 템플릿이 제공한 참조정보를 이용해서 작업을 수행하고 그 결과를 다시 템플릿에 돌려준다.                                                 |

템플릿은 콜백이 돌려준 정보를 사용해서 작업을 마저 수행하며, 경우에 따라 최종 결과를 클라이언트에 다시 돌려주기도 한다.

위의 방식에서는 클라이언트가 템플릿 메서드(`workWithStatementStrategy()`)를 호출하면서 메서드 레벨의 `DI`가 일어나면서 콜백 오브젝트를 주입한다. 메서드를 통해 주입해주는 `DI` 작업이 `workWithStatementStrategy()` 템플릿 메서드를 호출함과 동시에 일어나는 것이다.

일반적인 `DI`와 템플릿/콜백 방식에서의 `DI`는 다음과 같은 특징이 있다.

| 구분          | 특징                                                                                        |
| ------------- | ------------------------------------------------------------------------------------------- |
| 일반적인 `DI` | 템플릿에 인스턴스 변수를 생성해두고 사용할 의존 오브젝트를 수정자 메서드로 받아서 사용한다. |
| 템플릿/콜백   | 매번 메서드 단위로 사용할 오브젝트를 새롭게 전달받는다.                                     |

템플릿/콜백의 추가적인 특징은 다음과 같다.

- 콜백 오브젝트가 내부 클래스로서 자신을 생성한 클라이언트 메서드 내의 정보를 직접 참조한다.
- 클라이언트와 콜백이 강하게 결합된다.

이러한 템플릿/콜백 방식은 전략 패턴과 `DI`의 장점을 익명 내부 클래스 사용 전략과 결합한 독특한 활용법이라고 볼 수 있는데, 단순히 전략 패턴으로만 보기엔 독특한 특징이 많으므로 템플릿/콜백을 하나의 고유한 디자인 패턴으로 기억해두면 편리하다.

### JdbcContext에 적용된 템플릿/콜백

앞에서 작성한 `UserDao`, `JdbcContext`, `StatementStrategy`의 코드에는 템플릿/콜백 패턴이 적용되어 있는데, 각각의 역할은 앞서 살펴본 것와 같다.

| 구분       | 역할                                                                                                                                                                  |
| ---------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 클라이언트 | 템플릿 안에서 실행될 로직을 담은 콜백 오브젝트를 만들고, 콜백이 참조할 정보를 제공한다. 만들어진 콜백은 클라이언트가 템플릿의 메서드를 호출할 때 파라미터로 전달된다. |
| 템플릿     | 정해진 작업 흐름을 따라 작업을 진행하다가 내부에서 생성한 참조정보를 가지고 콜백 오브젝트의 메서드를 호출한다.                                                        |
| 콜백       | 클라이언트 메서드에 있는 정보와 템플릿이 제공한 참조정보를 이용해서 작업을 수행하고 그 결과를 다시 템플릿에 돌려준다.                                                 |

현재 `JdbcContext`의 `workWithStatementStrategy()` 템플릿 메서드는 리턴 값이 없는 단순한 구조인데, 조회 작업에서는 보통 템플릿의 작업 결과를 클라이언트에 리턴해준다. 그리고 템플릿의 작업 흐름이 복잡한 경우에는 한 번 이상 콜백을 호출하기도 하고 여러 개의 콜백을 클라이언트로부터 받아서 사용하기도 한다.

## 3.5.2 편리한 콜백의 재활용

### 콜백의 분리와 재활용

### 콜백과 템플릿의 결합

## 3.5.3 템플릿/콜백의 응용

### 테스트와 try/catch/finally

### 중복의 제거와 템플릿/콜백 설계

### 템플릿/콜백의 재설계

### 제네릭스를 이용한 콜백 인터페이스
