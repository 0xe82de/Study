# Contents

- [3.6.1 update()](#361-update)
- [3.6.2 queryForInt()](#362-queryForInt)
- [3.6.3 queryForObject()](#363-queryForObject)
- [3.6.4 query()](#364-query)
- [3.6.5 재사용 가능한 콜백의 분리](#365-재사용-가능한-콜백의-분리)

# 3.6 스프링의 JdbcTemplate

스프링은 `JDBC`를 이용하는 `DAO`에서 사용할 수 있도록 준비된 다양한 템플릿과 콜백을 제공한다. 스프링이 제공하는 `JDBC` 코드용 기본 템플릿은 `JdbcTemplate`이다.

앞에서 작성한 `JdbcContext`와 유사하지만 훨씬 강력하고 편리한 기능을 제공해준다. `JdbcContext`로 작성한 코드를 `JdbcTemplate`으로 수정하자.

```java
public class UserDao {
    private DataSource dataSource;
    private JdbcTemplate jdbcTemplate;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
        this.dataSource = dataSource;
    }
    // ...
}
```

위와 같이 `JdbcTemplate`의 생성자 파라미터로 `DataSource` 오브젝트를 주입해주면 된다.

## 3.6.1 update()

`deleteAll`() 메서드도 바꿔보자. `deleteAll()` 메서드에 처음 적용했던 콜백은 `StatementStrategy` 인터페이스의 `makePreparedStatement()` 메서드다. 이에 대응되는 `JdbcTemplate`의 콜백은 `PreparedStatementCreator` 인터페이스의 `createPreapredStatement()` 메서드다.

```java
public class UserDao {
    // ...
    public void deleteAll() throws SQLException {
        this.jdbcTemplate.update(
                new PreparedStatementCreator() {
                    @Override
                    public PreparedStatement createPreparedStatement(Connection connection) throws SQLException {
                        return connection.prepareStatement("delete from users");
                    }
                }
        );
    }
    // ...
}
```

위와 같이 `JdbcTemplate`을 이용하여 코드를 수정하였다. 앞서 작성했던 `executeSql()` 메서드는 `SQL` 문장만 전달하면 미리 준비된 콜백은 만들어서 템플릿을 호출하는 것까지 한 번에 해줬었다. `JdbcTemplate`에도 비슷한 메서드가 존재한다. `update()` 메서드와 이름은 동일한테 파라미터로 `SQL` 문장을 전달한다는 것만 다르다. 아래와 같이 간결하게 수정할 수 있다.

```java
public class UserDao {
    // ...
    public void deleteAll() throws SQLException {
        this.jdbcTemplate.update("delete from users");
    }
    // ...
}
```

이제 `add()` 메서드도 수정해보자. `add()` 메서드는 추가적으로 파라미터를 바인딩해야 하는데, 이를 지원하는 기능을 가진 `update()` 메서드를 사용하면 된다.

```java
public class UserDao {
    // ...
    public void add(final User user) throws SQLException {
        this.jdbcTemplate.update(
                "insert into users (id, name, password) values (?, ?, ?)",
                user.getId(),
                user.getName(),
                user.getPassword()
        );
    }
    // ...
}
```

위와 같이 파라미터를 순서대로 전달해주면 된다.

## 3.6.2 queryForInt()

`getCount()` 메서드에도 `JdbcTemplate`을 적용해보자. `getCount()` 메서드는 `SQL` 쿼리를 실행하고 `ResultSet`을 통해 결과 값을 가져오는 기능을 가진다. 이러한 작업 흐름에서 사용할 수 있는 템플릿은 `PreparedStatementCreator` 콜백과 `ResultSetExtractor` 콜백을 파라미터로 받는 `query()` 메서드다.

`ResultSetExtractor`는 `PreparedStatement`의 쿼리를 실행해서 얻은 `ResultSet`을 전달받는 콜백이다. `ResultSetExtractor` 콜백은 템플릿이 제공하는 `ResultSet`을 이용해 원하는 값을 추출해서 템플릿에 전달하면, 템플릿은 나머지 작업을 수행한 뒤에 그 값을 `query()` 메서드의 리턴 값으로 돌려준다.

```java
public class UserDao {
    // ...
    public int getCount() throws SQLException {
        return this.jdbcTemplate.query(new PreparedStatementCreator() {
            @Override
            public PreparedStatement createPreparedStatement(Connection connection) throws SQLException {
                return connection.prepareStatement("select count(*) from users");
            }
        }, new ResultSetExtractor<Integer>() {
            @Override
            public Integer extractData(ResultSet resultSet) throws SQLException, DataAccessException {
                resultSet.next();
                return resultSet.getInt(1);
            }
        });
    }
    // ...
}
```

`getCount()` 메서드를 위와 같이 수정할 수 있다. 첫 번째 `PreparedStatementCreator` 콜백은 템플릿으로부터 `Connection`을 받고 `PreparedStatement`를 돌려준다. 두 번째 `ResultSetExtractor`는 템플릿으로부터 `ResultSet`을 받고 거기서 추출한 결과를 돌려준다.

위의 콜백 오브젝트 코드는 재사용하기 좋은 구조다. `SQL`을 가지고 `PreparedStatement`를 만드는 첫 번째 콜백은 이미 재사용 방법을 알아봤고, 두 번째 콜백도 간단하다. `SQL`의 실행 결과가 하나의 정수 값이 되는 경우는 자주 볼 수 있는데, 클라이언트에서 콜백의 작업을 위해 특별히 제공할 값도 없어서 단순하다. 쉽게 `ResultSetExtractor` 콜백을 템플릿 안으로 옮겨 재활용할 수 있다.

`JdbcTemplate`은 이런 기능을 가진 콜백을 내장하고 있는 `queryForInt()`라는 편리한 메서드를 제공한다. `Integer` 타입의 결과를 가져올 수 있는 `SQL` 문장만 전달해주면 된다.

```java
public class UserDao {
    // ...
    public int getCount() throws SQLException {
        return this.jdbcTemplate.queryForInt("select count(*) from users");
    }
    // ...
}
```

위와 같이 `getCount()` 메서드의 코드를 한 줄로 수정할 수 었다. 예외처리와 안전한 리소스 반환, `DI`된 `DataSource`를 이용하는 것까지 기능은 모두 동일하다.

## 3.6.3 queryForObject()

## 3.6.4 query()

### 기능 정의와 테스트 작성

### query() 템플릿을 이용하는 getAll() 구현

### 테스트 보완

## 3.6.5 재사용 가능한 콜백의 분리

### DI를 위한 코드 정리

### 중복 제거

### 템플릿/볼백 패턴과 UserDao
