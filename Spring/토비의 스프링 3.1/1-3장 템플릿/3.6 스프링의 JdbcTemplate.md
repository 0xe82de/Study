# Contents

- [3.6.1 update()](#361-update)
- [3.6.2 queryForInt()](#362-queryForInt)
- [3.6.3 queryForObject()](#363-queryForObject)
- [3.6.4 query()](#364-query)
- [3.6.5 재사용 가능한 콜백의 분리](#365-재사용-가능한-콜백의-분리)

# 3.6 스프링의 JdbcTemplate

스프링은 `JDBC`를 이용하는 `DAO`에서 사용할 수 있도록 준비된 다양한 템플릿과 콜백을 제공한다. 스프링이 제공하는 `JDBC` 코드용 기본 템플릿은 `JdbcTemplate`이다.

앞에서 작성한 `JdbcContext`와 유사하지만 훨씬 강력하고 편리한 기능을 제공해준다. `JdbcContext`로 작성한 코드를 `JdbcTemplate`으로 수정하자.

```java
public class UserDao {
    private DataSource dataSource;
    private JdbcTemplate jdbcTemplate;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
        this.dataSource = dataSource;
    }
    // ...
}
```

위와 같이 `JdbcTemplate`의 생성자 파라미터로 `DataSource` 오브젝트를 주입해주면 된다.

## 3.6.1 update()

`deleteAll`() 메서드도 바꿔보자. `deleteAll()` 메서드에 처음 적용했던 콜백은 `StatementStrategy` 인터페이스의 `makePreparedStatement()` 메서드다. 이에 대응되는 `JdbcTemplate`의 콜백은 `PreparedStatementCreator` 인터페이스의 `createPreapredStatement()` 메서드다.

```java
public class UserDao {
    // ...
    public void deleteAll() throws SQLException {
        this.jdbcTemplate.update(
                new PreparedStatementCreator() {
                    @Override
                    public PreparedStatement createPreparedStatement(Connection connection) throws SQLException {
                        return connection.prepareStatement("delete from users");
                    }
                }
        );
    }
    // ...
}
```

위와 같이 `JdbcTemplate`을 이용하여 코드를 수정하였다. 앞서 작성했던 `executeSql()` 메서드는 `SQL` 문장만 전달하면 미리 준비된 콜백은 만들어서 템플릿을 호출하는 것까지 한 번에 해줬었다. `JdbcTemplate`에도 비슷한 메서드가 존재한다. `update()` 메서드와 이름은 동일한테 파라미터로 `SQL` 문장을 전달한다는 것만 다르다. 아래와 같이 간결하게 수정할 수 있다.

```java
public class UserDao {
    // ...
    public void deleteAll() throws SQLException {
        this.jdbcTemplate.update("delete from users");
    }
    // ...
}
```

이제 `add()` 메서드도 수정해보자. `add()` 메서드는 추가적으로 파라미터를 바인딩해야 하는데, 이를 지원하는 기능을 가진 `update()` 메서드를 사용하면 된다.

```java
public class UserDao {
    // ...
    public void add(final User user) throws SQLException {
        this.jdbcTemplate.update(
                "insert into users (id, name, password) values (?, ?, ?)",
                user.getId(),
                user.getName(),
                user.getPassword()
        );
    }
    // ...
}
```

위와 같이 파라미터를 순서대로 전달해주면 된다.

## 3.6.2 queryForInt()

`getCount()` 메서드에도 `JdbcTemplate`을 적용해보자. `getCount()` 메서드는 `SQL` 쿼리를 실행하고 `ResultSet`을 통해 결과 값을 가져오는 기능을 가진다. 이러한 작업 흐름에서 사용할 수 있는 템플릿은 `PreparedStatementCreator` 콜백과 `ResultSetExtractor` 콜백을 파라미터로 받는 `query()` 메서드다.

`ResultSetExtractor`는 `PreparedStatement`의 쿼리를 실행해서 얻은 `ResultSet`을 전달받는 콜백이다. `ResultSetExtractor` 콜백은 템플릿이 제공하는 `ResultSet`을 이용해 원하는 값을 추출해서 템플릿에 전달하면, 템플릿은 나머지 작업을 수행한 뒤에 그 값을 `query()` 메서드의 리턴 값으로 돌려준다.

```java
public class UserDao {
    // ...
    public int getCount() throws SQLException {
        return this.jdbcTemplate.query(new PreparedStatementCreator() {
            @Override
            public PreparedStatement createPreparedStatement(Connection connection) throws SQLException {
                return connection.prepareStatement("select count(*) from users");
            }
        }, new ResultSetExtractor<Integer>() {
            @Override
            public Integer extractData(ResultSet resultSet) throws SQLException, DataAccessException {
                resultSet.next();
                return resultSet.getInt(1);
            }
        });
    }
    // ...
}
```

`getCount()` 메서드를 위와 같이 수정할 수 있다. 첫 번째 `PreparedStatementCreator` 콜백은 템플릿으로부터 `Connection`을 받고 `PreparedStatement`를 돌려준다. 두 번째 `ResultSetExtractor`는 템플릿으로부터 `ResultSet`을 받고 거기서 추출한 결과를 돌려준다.

위의 콜백 오브젝트 코드는 재사용하기 좋은 구조다. `SQL`을 가지고 `PreparedStatement`를 만드는 첫 번째 콜백은 이미 재사용 방법을 알아봤고, 두 번째 콜백도 간단하다. `SQL`의 실행 결과가 하나의 정수 값이 되는 경우는 자주 볼 수 있는데, 클라이언트에서 콜백의 작업을 위해 특별히 제공할 값도 없어서 단순하다. 쉽게 `ResultSetExtractor` 콜백을 템플릿 안으로 옮겨 재활용할 수 있다.

`JdbcTemplate`은 이런 기능을 가진 콜백을 내장하고 있는 `queryForInt()`라는 편리한 메서드를 제공한다. `Integer` 타입의 결과를 가져올 수 있는 `SQL` 문장만 전달해주면 된다.

```java
public class UserDao {
    // ...
    public int getCount() throws SQLException {
        return this.jdbcTemplate.queryForInt("select count(*) from users");
    }
    // ...
}
```

위와 같이 `getCount()` 메서드의 코드를 한 줄로 수정할 수 었다. 예외처리와 안전한 리소스 반환, `DI`된 `DataSource`를 이용하는 것까지 기능은 모두 동일하다.

## 3.6.3 queryForObject()

이번에는 `get()` 메서드에 `JdbcTemplate`을 적용해보자. `get()` 메서드는 바인딩이 필요한 치환자를 가지고 있다. 이것은 `add()` 메서드에서 사용했던 방법을 적용하면 된다. 그리고 `ResultSet`을 통해 `User` 오브젝트를 만들어서 프로퍼티에 넣어줘야 한다. 이를 위해, `getCount()`에 적용했던 `ResultSetExtractor` 콜백 대신 `RowMapper` 콜백을 사용한다.

두 콜백은 모두 템플릿으로부터 `ResultSet`을 전달받고, 필요한 정보를 추출해서 리턴하는 방식으로 동작한다. 다른 점은 다음과 같다.

| 콜백                 | 차이                                                                                       |
| -------------------- | ------------------------------------------------------------------------------------------ |
| `ResultSetExtractor` | `ResultSet`을 한 번 전달받아 알아서 추출 작업을 모두 진행하고 최종 결과만 리턴해주면 된다. |
| `RowMapper`          | `ResultSet`의 로우 하나를 매핑하기 위해서 사용되므로 여러 번 호출될 수 있다.               |

기본키 값으로 조회하는 `get()` 메서드의 `SQL` 실행 결과는 로우가 하나인 `ResultSet`이다. `ResultSet`의 첫 번째 로우에 `RowMapper`를 적용하도록 만들면 되는데, `RowMapper` 콜백은 첫 번째 로우에 담긴 정보를 하나의 `User` 오브젝트에 매핑하게 해주면 된다.

이를 위해 사용할 템플릿 메서드는 `queryForObject()`다.

```java
public class UserDao {
    // ...
    public User get(String id) throws SQLException {
        return this.jdbcTemplate.queryForObject(
                "select * from users where id = ?",
                new Object[]{id}, // SQL에 바인딩할 파라미터 값, 가변인자 대신 배열을 사용한다.
                new RowMapper<User>() {
                    @Override
                    public User mapRow(ResultSet resultSet, int i) throws SQLException {
                        User user = new User();
                        user.setId(resultSet.getString("id"));
                        user.setName(resultSet.getString("name"));
                        user.setPassword(resultSet.getString("password"));
                        return user;
                    }
                }
        );
    }
    // ...
}
```

위의 코드는 `queryForObject`와 `RowMapper`를 적용한 `get()` 메서드다. 첫 번째 파라미터는 `PreparedStatement`를 만들기 위한 `SQL`이고, 두 번째는 바인딩할 값들이다. `queryForObject()` 내부에서 이 두 가지 파라미터를 사용하는 `PreparedStatement` 콜백이 만들어질 것이다.

`queryForObject()`는 `SQL`을 실행하면 한 개의 로우만 얻을 것이라고 기대한다. `ResultSet`의 `next()`를 실행해서 첫 번째 로우로 이동시킨 후에 `RowMapper` 콜백을 호출하므로 호출되는 시점에서 `ResultSet`은 첫 번째 로우를 가리키고 있다. 즉, `rs.next()`를 호출할 필요는 없다. `RowMapper`에서는 현재 `ResultSet`이 가리키는 로우의 내용을 `User` 오브젝트에 담아서 리턴해주기만 하면 된다.

이로써 `User` 오브젝트를 조회하는 `get()` 메서드의 기본 기능을 충분히 구현됐지만 한 가지 더 고려애햐 할 게 있다.

기존의 `get()` 메서드는 조회 결과가 없을 때 `EmptyResultDataAccessException`을 던지도록 만들었다. `queryForObject()`를 이용할 때는 조회 결과가 없는 예외 상황을 어떻게 처리해야 할까? 이를 위해 처리해줄 것은 없다. 이미 `queryForObject()`는 `SQL`을 실행해서 받은 로우의 개수가 하나가 아니라면 예외를 던지도록 만들어져 있다. 이 때 던져지는 예외가 바로 `EmptyResultDataAccessException`이다.

## 3.6.4 query()

### 기능 정의와 테스트 작성

### query() 템플릿을 이용하는 getAll() 구현

### 테스트 보완

## 3.6.5 재사용 가능한 콜백의 분리

### DI를 위한 코드 정리

### 중복 제거

### 템플릿/볼백 패턴과 UserDao
