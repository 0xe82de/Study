# Contents

- [3.4.1 JdbcContext의 분리](#341-JdbcContext의-분리)
- [3.4.2 JdbcContext의 특별한 DI](#342-JdbcContext의-특별한-DI)

# 3.4 컨텍스트와 DI

## 3.4.1 JdbcContext의 분리

| 전략 패턴 구조 | 대상                                        |
| -------------- | ------------------------------------------- |
| 클라이언트     | `UserDao`의 메서드                          |
| 개별적인 전략  | `UserDao`의 메서드의 익명 내부 클래스       |
| 컨텍스트       | `jdbcContextWithStatementStrategy()` 메서드 |

`UserDao`를 전략 패턴 구조로 나타내면 위와 같다.

컨텍스트 메서드는 `UserDao` 내의 `PreparedStatement`를 실행하는 기능을 가진 메서드에서 공유할 수 있다. 그런데 `JDBC`의 일반적인 작업 흐름을 담고 있는 `jdbcContextWithStatementStrategy()`는 다른 `DAO`에서도 사용할 수 있으므로 `jdbcContextWithStatementStrategy()`를 `UserDao` 클래스 밖으로 독립시켜서 모든 `DAO`가 사용할 수 있도록 하자.

### 클래스 분리

아래와 같이 `JdbcContext` 클래스를 생성하고 `jdbcContextWithStatementStrategy()` 메서드를 작성한다. 이름은 `workWithStatementStrategy`로 수정한다.

```java
public class JdbcContext {
    private DataSource dataSource;

    public void setDataSource(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    public void workWithStatementStrategy(StatementStrategy stmt) throws SQLException {
        Connection c = null;
        PreparedStatement ps = null;

        try {
            c = dataSource.getConnection();
            ps = stmt.makePreparedStatement(c);
            ps.executeUpdate();
        } catch (SQLException e) {
            throw e;
        } finally {
            if (ps != null) {
                try {
                    ps.close();
                } catch (SQLException e) {
                }
            }
            if (c != null) {
                try {
                    c.close();
                } catch (SQLException e) {
                }
            }
        }
    }
}
```

위와 같이 `jdbcContextWithStatementStrategy()` 메서드를 독립시키면 `DataSource`가 필요한 것은 `UserDao`가 아니라 `JdbcContext`가 된다. `DB` 커넥션을 필요로 하는 코드는 `JdbcContext` 안에 있기 때문이다. 따라서 `JdbcContext`가 `DataSource`에 의존하고 있으므로 `DataSource` 타입의 `빈`을 `DI`받을 수 있도록 한다.

```java
public class UserDao {
    // ...
    private JdbcContext jdbcContext;

    public void setJdbcContext(JdbcContext jdbcContext) {
        this.jdbcContext = jdbcContext; // JdbcContext를 DI 받도록 한다.
    }

    public void add(final User user) throws SQLException {
        // DI 받은 JdbcContext의 컨텍스트 메서드를 사용하도록 변경한다.
        this.jdbcContext.workWithStatementStrategy(
                new StatementStrategy() {
                    // ...
                }
        );
    }

    public void deleteAll() throws SQLException {
        // DI 받은 JdbcContext의 컨텍스트 메서드를 사용하도록 변경한다.
        this.jdbcContext.workWithStatementStrategy(
                new StatementStrategy() {
                    // ...
                }
        );
    }
    // ...
}
```

다음은 `UserDao`가 분리된 `JdbcContext`를 `DI` 받아서 사용할 수 있도록 한다.

### 빈 의존관계 변경

`UserDao`는 이제 `JdbcContext`에 의존한다. 그런데 `JdbcContext`는 인터페이스인 `DataSource`와 달리 구체 클래스다. 스프링의 `DI`는 기본적으로 인터페이스를 사이에 두고 의존 클래스를 바꿔서 사용하도록 하는 것이 목적이다.

하지만 이 경우에 `JdbcContext`는 그 자체로 독립적인 `JDBC` 컨텍스트를 제공해주는 서비스 오브젝트로서 의미가 있을 뿐이고 구현 방법이 바뀔 가능성은 없으므로 인터페이스를 구현하도록 만들지 않았다. `UserDao`, `JdbcContext`는 인터페이스를 사이에 두지 않고 `DI`를 적용하는 특별한 구조가 된다.

스프링의 `빈` 설정은 런타임 시에 만들어지는 오브젝트 레벨의 의존관계에 따라 정의된다. 기존에는 `userDao 빈`이 `dataSource 빈`을 직접 의존했지만 이제는 `jdbcContext 빈`이 그 사이에 끼게 된다.

새로운 `빈` 의존관계에 따라서 `test-applicationContext.xml` 파일을 수정한다.

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">

        <bean id="userDao" class="springbook.user.dao.UserDao">
                <!-- UserDao 내에 아직 JdbcContext를 적용하지 않은 메서드가 있으므로 제거하지 않는다. -->
                <property name="dataSource" ref="dataSource" />
                <property name="jdbcContext" ref="jdbcContext" />
        </bean>
        <!-- 추가된 JdbcContext 타입 빈 -->
        <bean id="jdbcContext" class="springbook.user.dao.JdbcContext">
                <property name="dataSource" ref="dataSource" />
        </bean>
        <bean id="dataSource" class="org.springframework.jdbc.datasource.SimpleDriverDataSource">
                <property name="driverClass" value="org.h2.Driver" />
                <property name="url" value="jdbc:h2:tcp://localhost/~/testdb" />
                <property name="username" value="sa" />
                <property name="password" value="sa" />
        </bean>
</beans>

```

## 3.4.2 JdbcContext의 특별한 DI

### 스프링 빈으로 DI

### 코드를 이용하는 수동 DI
