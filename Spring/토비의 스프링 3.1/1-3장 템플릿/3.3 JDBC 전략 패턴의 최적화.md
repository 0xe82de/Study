# Contents

- [3.3.1 전략 클래스의 추가 정보](#331-전략-클래스의-추가-정보)
- [3.3.2 전략과 클라이언트의 동거](#332-전략과-클라이언트의-동거)

# 3.3 JDBC 전략 패턴의 최적화

독립된 `JDBC` 작업 흐름이 담긴 `jdbcContextWithStatementStrategy()`는 `DAO` 메서드들이 공유할 수 있게 됐다. `DAO` 메서드는 전략 패턴의 클라이언트로서 컨텍스트에 해당하는 `jdbcContextWithStatementStrategy()` 메서드에 적절한 전략, 즉 바뀌는 로직을 제공해주는 방법으로 사용할 수 있다.

여기서 컨텍스트는 `PreparedStatement`를 실행하는 `JDBC`의 작업 흐름이고, 전략은 `PreparedStatement`를 생성하는 것이다.

## 3.3.1 전략 클래스의 추가 정보

`add()` 메서드에도 적용하기 위해 아래와 같이 `AddStatement` 클래스를 작성한다.

```java
// dao.AddStatement
public class AddStatement implements StatementStrategy {
    User user;

    public AddStatement(User user) {
        this.user = user;
    }

    @Override
    public PreparedStatement makePreparedStatement(Connection c)
            throws SQLException {
        PreparedStatement ps =
                c.prepareStatement("insert into users(id, name, password) values(?, ?, ?)");
        ps.setString(1, user.getId());
        ps.setString(2, user.getName());
        ps.setString(3, user.getPassword());

        return ps;
    }
}
```

`add()`는 `deleteAll()`과 달리 `PreparedStatement`를 만들 때 `user`라는 부가 정보가 필요하므로, `User` 타입 오브젝트를 생성자를 통해 받도록 한다. 그리고 `UserDao`의 `add()` 메서드는 다음과 같이 수정한다.

```java
public class UserDao {
    // ...
    public void add(User user) throws SQLException {
        StatementStrategy st = new AddStatement(user);
        jdbcContextWithStatementStrategy(st);
    }
    // ...
}
```

위와 같이 클라이언트인 `UserDao`의 `add()` 메서드에서 `user` 정보를 생성자를 통해 전달하도록 수정한다.

## 3.3.2 전략과 클라이언트의 동거

### 로컬 클래스

### 익명 내부 클래스
