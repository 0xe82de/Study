# Contents

- [5.2.1 모 아니면 도](#521-모-아니면-도)
- [5.2.2 트랜잭션 경계설정](#522-트랜잭션-경계설정)
- [5.2.3 트랜잭션 동기화](#523-트랜잭션-동기화)
- [5.2.4 트랜잭션 서비스 추상화](#524-트랜잭션-서비스-추상화)

# 5.2 트랜잭션 서비스 추상화

## 5.2.1 모 아니면 도

모든 사용자에 대해 업그레이드 작업을 진행하다가 중간에 예외가 발생해서 작업이 중단되면 어떻게 될까? 테스트 코드를 작성해서 확인해보자. 하지만 이번 테스트는 간단하지 않은데, 예외적인 상황을 작업 중간에 발생시켜야 하기 때문이다. 예외가 던져지는 상황을 의도적으로 만드는 게 나을 것 같다.

### 테스트용 UserService 대역

작업 중간에 예외를 강제로 만드는 가장 쉬운 방법은 예외를 강제로 발생시키도록 애플리케이션 코드를 수정하는 것이다. 하지만 테스트를 위해 코드를 함부로 수정하는 것은 좋은 생각이 아니다. 이런 경우엔 테스트용으로 만든 `UserService`의 대역을 사용하는 방법이 좋다. `UserService`를 대신해서 테스트의 목적에 맞게 동작하는 클래스를 만들어서 사용하는 것이다. `UserService`를 상속해서 테스트에 필요한 기능을 추가하도록 일부 메서들르 오버라이딩하면 된다.

현재 5개의 테스트용 사용자 정보 중에서 두 번째와 네 번째가 업그레이드 대상이다. 네 번째 사용자를 처리하는 중에 예외를 발생시키고, 그 전에 처리한 두 번째 사용자의 정보가 취소됐는지, 그대로 남았는지를 확인하면 된다.

테스트용으로 `UserService`를 상속한 클래스를 테스트 클래스 내부에 `static` 클래스로 만들자. 그런데 `UserService`의 메서드들의 접근제한자가 `private`이므로 오버리이딩이 불가능하다. 테스트 코드는 테스트 대상 클래스의 내부의 구현 내용을 고려해서 밀접하게 접근해야 하는데, `private`처럼 제약이 강한 접근제한자를 사용하면 불편하다. 테스트를 위한 애플리케이션 코드 수정은 피하는 것이 좋지만 이번은 예외로 해야겠다.

오버라이딩하려는 메서드는 `upgradeLevel()` 메서드다. 이 메서드에 전달되는 `User` 오브젝트를 확인해서 네 번째 `User` 오브젝트가 전달됐을 때 강제로 예외를 발생시키면 된다.

먼저 `UserService`의 `upgradeLevel()` 메서드의 접근제한자를 `protected`로 수정한다.

```java
public class UserService {
    // ...
    protected void upgradeLevel(User user) {
        user.upgradeLevel();
        userDao.update(user);
    }
}
```

그런 다음 `UserService`를 상속한 클래스를 `UserServiceTest` 클래스 내부에 추가한다.

```java
public class UserServiceTest {
    static class TestUserServiceException extends RuntimeException {
    }

    static class TestUserService extends UserService {
        private String id;
        private TestUserService(String id) {
            this.id = id;
        }

        @Override
        protected void upgradeLevel(User user) {
            if (user.getId().equals(this.id)) throw new TestUserServiceException();
            super.upgradeLevel(user);
        }
    }
    // ...
}
```

위와 같이 오버라이드된 `upgradeLevel()` 메서드는 `UserService` 메서드의 기능을 그대로 수행하지만 미리 지정된 `id`를 가진 사용자가 전달되면 예외를 던지도록 작성했다. 다른 예외가 발생했을 경우와 구분하기 위해 테스트 목적을 띤 `TestUserServiceException` 클래스를 정의해두자.

### 강제 예외 발생을 통한 테스트

이제 테스트를 작성해보자. 테스트의 목적은 사용자 레벨 업그레이드를 시도하다가 중간에 예외가 발생했을 경우, 그 전에 업그레이드했던 사용자도 다시 원래 상태로 돌아갔는지 확인하는 것이다.

```java
public class UserServiceTest {
    // ...
    @Test
    public void upgradeAllOrNothing() {
        UserService testUserService = new TestUserService(users.get(3).getId());
        testUserService.setUserDao(this.userDao);

        userDao.deleteAll();
        for (User user : users) userDao.add(user);

        try {
            testUserService.upgradeLevels();
            fail("TestUserServiceException expected");
        }
        catch (TestUserServiceException e) {
        }

        checkLevelUpgraded(users.get(1), false);
    }
    // ...
}
```

테스트 코드는 위와 같다. 먼저 테스트용으로 만들어둔 `TestUserService`의 오브젝트를 생성하고, 생성자 파라미터로 예외를 발생시킬 사용자의 `id`를 전달한다. 그리고 스프링 컨텍스트로부터 가져온 `userDao`를 테스트용 `TestUserService`에 수동으로 `DI`한다.

그런 다음 5개의 사용자 정보를 등록하고, `testUserService`의 `upgradeLevels()` 메서드를 실행한다. 5개의 `User`를 가져와 업그레이드를 하다가 지정해둔 네 번째 사용자 오브젝트 순서가 되면 `TestUserServiceException`을 발생시킬 것이다. 혹시라도 테스트 코드를 잘못 작성해서 예외가 발생하지 않더라도 `fail()` 메서드 때문에 테스트는 실패할 것이다. `fail()` 메서드는 테스트가 의도한대로 동작하는지를 확인하기 위해 넣은 것이다.

`TestUserServiceException`을 잡은 후에는 `checkLevelUpgraded()` 메서드를 사용하여 두 번째 사용자의 레벨이 변경됐는지 확인한다. 예외가 발생하여 작업이 중단됐으니 이미 레벨을 수정했던 두 번째 사용자도 원래 상태로 돌아가야 한다.

테스트를 실행해보면 다음과 같은 메시지를 출력하고 실패한다.

```java
java.lang.AssertionError:
Expected: is <BASIC>
     got: <SILVER>
```

레벨이 업그레이드되고 원래 상태도 돌아가지 않았다.

### 테스트 실패의 원인

테스트가 실패한 이유는 간단하다. 모든 사용자의 레벨을 업그레이드하는 작업인 `upgradeLevels()` 메서드가 하나의 트랜잭션 안에서 동작하지 않았기 때문이다. 모든 사용자에 대한 레벨 업그레이드 작업은 전체가 다 성공하든지, 다 실패하든지 해야 한다.

`upgradeLevels()` 메서드의 작업은 이 하나의 작업 단위인 트랜잭션이 적용되지 않았으므로 테스트가 실패하는 것이다.

## 5.2.2 트랜잭션 경계설정

### JDBC 트랜잭션의 트랜잭션 경계설정

### UserService와 UserDao의 트랜잭션 문제

### 비즈니스 로직 내의 트랜잭션 경계설정

### UserService 트랜잭션 경계설정의 문제점

## 5.2.3 트랜잭션 동기화

### Connection 파라미터 제거

### 트랜잭션 동기화 적용

### 트랜잭션 테스트 보완

### JdbcTemplate과 트랜잭션 동기화

## 5.2.4 트랜잭션 서비스 추상화

### 기술과 환경에 종속되는 트랜잭션 경계설정 코드

### 트랜잭션 API의 의존관계 문제와 해결책

### 스프링의 트랜잭션 서비스 추상화

### 트랜잭션 기술 설정의 분리
