# 5.3 서비스 추상화와 단일 책임 원칙

이제 스프링의 트랜잭션 추상화 기법을 이용해 다양한 트랜잭션 기술을 일관된 방식으로 제어할 수 있게 되었다. 설정을 고치는 것만으로도 `DB` 연결 기술, 데이터 액세스 기술, 트랜잭션 기술을 자유롭게 바꿔서 사용할 수 있다.

### 수직, 수평 계층구조와 의존관계

이렇게 기술과 서비스에 대한 추상화 기법을 이용하면 특정 기술환경에 종속되지 않는 포터블한 코드를 작성할 수 있다. `UserDao`와 `UserService`는 각각 담당하는 코드의 기능적인 관심에 따라 분리되고, 서로 불필요한 영향을 주지 않으면서 독자적으로 확장이 가능하도록 만든 것이다. 같은 애플리케이션 로직을 담은 코드지만 내용에 따라 분리했으며, 같은 계층에서 수평적인 분리라고 볼 수 있다.

트랜잭션의 추상화는 이와는 좀 다른데, 애플리케이션의 비즈니스 로직과 그 하위에서 동작하는 로우레벨의 트랜잭션 기술이라는 아예 다른 계층의 특성을 가지는 코드를 분리한 것이다.

| 계층               | 코드, 기술                                                     | 의존 관계 |
| ------------------ | -------------------------------------------------------------- | :-------: |
| 애플리케이션 계층  | `UserService` -> `UserDao`                                     |     ↓     |
| 서비스 추상화 계층 | `TransactionManager` -> `DataSource`                           |     ↓     |
| 기술 서비스 계층   | `JDBC`, `JTA`, `Connection Pooling`, `JNDI`, `WAS`, `Database` |     ↓     |

위 표는 지금까지 만든 사용자 관리 모듈의 의존관계를 나타낸다. `UserDao`와 `UserService`는 인터페이스와 `DI`를 통해 연결됨으로써 결합도가 낮아졌다. 결합도가 낮아진다는 것은 서로의 코드에 영향을 주지 않는다는 뜻이며, 독립적으로 확장될 수 있다는 것이다.

`UserDao`는 `DB` 연결을 생성하는 방법도 독립적이다. `DataSource` 인터페이스와 `DI`를 통해 추상화된 방식으로 로우에벨의 `DB` 연결 기술을 사용하기 때문이다. 마찬가지고 `UserService`와 트랜잭션 기술과도 스프링이 제공하는 `PlatformTransactionManager` 인터페이스를 통한 추상화 계층을 사이에 두고 사용하게 했으므로 구체적인 트랜잭션 기술에 독립적인 코드가 됐다.

애플리케이션 로직의 종류에 따른 수평적인 구분이든, 로직과 기술이라는 수직적인 구분이든 모두 결합도가 낮으며, 서로 영향을 주지 않고 자유롭게 확장될 수 있는 구조를 만들 수 있는 데는 스프링의 `DI`가 중요한 역할을 하고 있다. `DI`의 가치는 이렇게 `관심`, `책임`, `성격`이 다른 코드를 깔끔하게 분리하는 데 있다.

### 단일 책임 원칙

이러한 적절한 분리가 가져오는 특징은 객체지향 설계의 원칙 중의 하나인 `단일 책임 원칙(Single Responsibility Principle)`으로 설명할 수 있다. 단일 책임 원칙은 하나의 모듈은 한 가지 책임을 가져야 한다는 의미로, 하나의 모듈이 바뀌는 이유는 한 가지여야 한다고 설명할 수 있다.

`UserService`에 `JDBC Connection` 메서드를 직접 사용하는 트랜잭션 코드가 있을 때를 생각해보면 `UserService`는 `어떻게 사용하 레벨을 관리할 것인가`와 `어떻게 트랜잭션을 관리할 것인가`라는 두 가지 책임을 가지고 있었다. 두 가지 책임을 가지고 있다는 것은 `UserService` 코드가 수정되는 이유가 두 가지라는 뜻이다. 즉, `UserService`는 단일 책임 원칙을 지키지 못하고 있었던 것이다.

하지만 트랜잭션 서비스의 추상화 방식을 도입하고, 이를 `DI`를 통해 외부에서 제어하도록 만든 후에는 `UserService` 코드가 수정될 이유는 한 가지가 되었다. 트랜잭션 기술이 바뀌고, 사용할 서버환경이 바뀌고, 또는 `UserDao`의 데이터를 가져오는 테이블이 바뀌고, `UserDao`의 구현 기술이 `JDBC`에서 `JPA`로 바뀌더라도 `UserService` 코드는 단 한 줄도 수정할 이유가 없다. 따라서 단일 책임 원칙을 충실하게 지키고 있는 것이다.

### 단일 책임 원칙의 장점

이렇게 단일 책임 원칙을 지키는 코드가 되면 어떠한 장점이 있을까?

일단 단일 책임 원칙을 잘 지키고 있다면, 어떤 변경이 필요할 때 수정 대상이 명확해진다. 기술이 바뀌면 기술 계층과의 연동을 담당하는 기술 추상화 계층의 설정만 바꿔주면 된다. 데이터를 가져오는 테이블의 이름이 바뀌었다면 데이터 액세스 로직을 담고 있는 `UserDao`를 변경하면 된다. 비즈니스 로직도 마찬가지다.

`DAO`가 수백 개가 되과, 서비스 클래스도 그만큼 많다고 가정해보자. 서비스 하나가 여러 개의 `DAO`를 사용하는 경우가 많아지고 의존관계가 매우 복잡해질 것이다. 만약 한 개의 `DAO`를 수정핳 경우 그에 의존하고 있는 서비스 클래스도 같이 수정해야 하는 구조라면 어떻게 될까? `UserDao`를 수백 군데에서 사용하고 있다면 수백 개의 클래스를 모두 수정해야 한다.

기술적인 수정사항도 마찬가지다. 애플리케이션 계층의 코드가 특정 기술에 종속되어서 기술이 바뀔 때마다 코드의 수정이 필요하다면 어떨지 가정해보자. 그나마 트랜잭션 동기화 기법을 사용해 서비스 클래스의 코드를 간략히 했다고 하더라도 `JDBC`에서 `JTA`로 트랜잭션 기술이 변경되면, 아마 그에 따라 (서비스 클래스 수) X (트랜잭션을 사용하느 메서드 수)만큼의 많은 코드를 수정해야 할 것이다. 반면에 `XML` 설정을 몇 줄 수정하는 것으로 트랜잭션 기술을 한 번에 전환하는 방식을 비교해보면 그 차이는 상상도 할 수 없을 만큼 클 것이다.

그래서 적절하게 책임과 관심을 다른 코드로 분리하고, 서로 영향을 주지 않도록 다양한 추상화 기법을 도입하고, 애플리케이션 로직과 기술/환경을 분리하는 등의 작업은 갈수록 복잡해지는 엔터프라이즈 애플리케이션에는 반드시 필요하다. 이를 위한 핵심적인 도구가 스프링이 제공하는 `DI`다.

객체지향 설계와 프로그래밍의 원칙은 서로 긴밀하게 관련이 있다. 단일 책임 원칙을 잘 지키는 코드를 작성하려면 인터페이스를 사용하고 `DI`로 연결해야 하며, 그 결과로 단일 책임 원칙 뿐만 아니라 개방 폐쇄 원칙도 잘 지키고, 모듈 간에 결합도가 낮아서 서로의 변경이 영향을 주지 않고, 같은 이유로 변경이 단일 책임에 집중되는 응집도 높은 코드가 나오기 때문이다. 또한 이런 과정에서 전략 패턴, 어댑터 패턴, 브리지 패턴, 미디에이터 패턴 등 많은 디자인 패턴이 자연스럽게 적용되기도 한다. 객체지향 설계 원칙을 잘 지켜서 작성한 코드는 테스트하기도 편하다. 스프링이 지원하는 `DI`와 싱글톤 레지스트리 덕분에 편리하게 자동화된 테스트를 만들 수 있다.

이렇게 스프링의 의존관계 주입 기술인 `DI`는 모든 스프링 기술의 기반이 되는 핵심 엔진이자 원리이며, 스프링이 지지하고 지원하는, 좋은 설계와 코드를 만드는 모든 과정에서 사용되는 가장 중요한 도구다.
