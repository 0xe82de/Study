# Contents

- [4.2.1 JDBC의 한계](#421-JDBC의-한계)
- [4.2.2 DB 에러 코드 매핑을 통한 전환](#422-DB-에러-코드-매핑을-통한-전환)
- [4.2.3 DAO 인터페이스와 DataAccessException 계층구조](#423-DAO-인터페이스와-DataAccessException-계층구조)
- [4.2.4 기술에 독립적인 UserDao 만들기](#424-기술에-독립적인-UserDao-만들기)

# 4.2 예외 전환

예외 전환의 목적은 다음과 같이 두 가지이다.

- `런타임 예외`로 포장해서 굳이 필요하지 않은 `catch/throws`문을 줄이는 것이다.
- 로우레벨의 예외를 의미 있고 추상화된 예외로 바꿔서 던지는 것이다.

스프링의 `JdbcTemplate`의 역할은 다음과 같다.

- `JdbcTemplate`이 던지는 `DataAccessException`은 `SQLException`을 `런타임 예외`로 포장한다. 이를 통해 애플리케이션 레벨에서는 복구가 불가능한 `SQLException` 예외에 대해 신경 스지 않도록 해주는 것이다.
- `DataAccessException`은 `SQLException`에 담긴 상세한 예외정보를 의미 있고 일관성 있는 예외로 전환해서 추상화해주려는 용도로도 쓰인다.

## 4.2.1 JDBC의 한계

`DB`별로 다른 `API`를 제공하고 이를 사용해야 한다고 가정해보자. `DB`가 바뀔 때마다 `DAO` 코드도 바뀔 것이다. 또한, 각각의 `API` 사용 방법도 익혀야 한다.

`JDBC`는 자바를 이용해 `DB`에 접근하는 방법을 추상화된 `API` 형태로 정의해놓고, 각 `DB` 업체가 `JDBC` 표준을 따라 만들어진 드라이버를 제공하게 해준다. 내부 구현은 다르지만 `JDBC`의 표준 인터페이스인 `Connection`, `Statement`, `ResultSet` 등을 통해 기능을 제공해주므로 자바 개발자들은 표준화된 `JDBC`의 `API`만 익숙해지면 `DB`의 종류에 상관없이 일관된 방법으로 프로그램을 개발할 수 있다. 인터페이스를 사용하는 객체지향 프로그래밍 방법의 장점을 잘 경험할 수 있는 것이 바로 `JDBC`다.

하지만 `DB` 종류에 상관없이 사용할 수 있는 데이터 액세스 코드를 작성하는 것은 어렵다. 현실적으로 `DB`를 자유롭게 바꾸어 사용할 수 있는 `DB` 프로그램을 작성하는 데는 두 가지 어려움이 있다.

### 비표준 SQL

첫 번째 문제는 `JDBC` 코드에서 사용하는 `SQL`이다. 대부분의 `DB`는 표준을 따르지 않는 비표준 문법과 기능을 제공하는데, 이러한 비표준 특정 `DB` 전용 문법이 폭넓게 사용되고 있다. 해당 `DB`의 특별한 기능을 사용하거나 최적화된 `SQL`을 만들 떄 유용하기 때문이다.

이렇게 작성된 비표준 `SQL`은 `DAO` 코드에 들어가고 해당 `DAO`는 특정 `DB`에 종속적인 코드가 된다. 다른 `DB`로 변경하려면 `DAO`에 담긴 `SQL`을 꽤 수정해야 할 것이다. 일반적으로 `DB`가 바뀌지 않고, 사용하는 `DB`에 최적화하는 것이 중요하므로 비표준 `SQL`을 거리낌없이 사용한다. 하지만 `DB`의 변경 가능성을 고려한다면 비표준 `SQL`은 큰 문제가 된다.

이 문제의 해결책을 생삭해보면, 호환 가능한 표준 `SQL`만 사용하거나 `DB`별로 별도의 `DAO`를 만들거나 `SQL`을 외부에 독립시켜서 `DB`에 따라 변경해 사용하도록 할 수 있다. 표준 `SQL`만을 사용할 경우 웹 프로그램에서 자주 필요로 하는 페이징 쿼리에서부터 문제가 되므로 표준 `SQL`은 해결채깅 될 수 없다. 따라서, `DB`별로 `DAO`를 만들거나 `SQL`을 외부로 독립시켜야 한다.

### 호환성 없는 SQLException의 DB 에러정보

두 번째 문제는 `SQLException`이다. `DB`를 사용하다가 발생할 수 있는 예외의 원인은 다양한데, 대표적으로 다음과 같은 원인이 있다.

- `SQL` 문법 오류
- `DB` 커넥션 생성 실패
- 존재하지 않는 테이블 또는 필드를 사용
- 키 중복
- 제약조건 위배
- 데드락

여기서 문제는 `DB`마다 `SQL`만 다른 것이 아니라 에러의 종류와 원인도 다르다는 것이다. 그래서 `JDBC`는 데이터 처리 중에 발생하는 다양한 예외를 `SQLException` 하나에 모두 담아버린다. 예외가 발생하는 원인은 `SQLException` 안에 담긴 에러 코드와 `SQL` 상태 정보를 참조해봐야 한다. 그런데, `DB` 벤더가 정의한 고유한 에러코드가 각각 다르기 때문에 `SQLException`의 `getErrorCode()`로 가져올 수 있는 `DB` 에러 코드는 `DB`별로 다르다.

앞서 작성한 `add()` 메서드에서는 새로운 사용자를 등록하다가 키가 중복되어 예외가 발생하는 경우를 확인하기 위하여 다음과 같은 방법을 사용했었다.

```java
if (e.getErrorCode() == MysqlErrorNumbers.ER_DUP_ENTRY) { /* ... */ }
```

위의 코드는 `MySQL` 전용 코드일 뿐이다. `DB`가 바뀐다면 위 코드는 기대한 대로 동작하지 못할 것이다. 그래서 `SQLException`은 예외가 발생했을 때의 `DB` 상태를 담은 `SQL` 상태정보를 부가적으로 제공하는데, `getSQLState()` 메서드로 예외상황에 대한 상태정보를 가져올 수 있다. 이 상태정보는 `DB`별로 달라지는 에러 코드를 대신할 수 있도록, `Open Group`의 `XOPEN SQL` 스펙에 정의된 `SQL 상태 코드를 따르도록 되어 있다.

`SQLException`이 이러한 상태 코드를 제공하는 이유는 `DB`에 독립적인 에러정보를 얻기 위해서다. 그런데 문제가 있다. `JDBC` 드라이버에서 `SQLException`을 담을 상태 코드를 정확하게 만들어주지 않는다. 결과적으로 이 `SQL` 상태 코드를 믿고 결과를 파악하는 것은 위험하다.

결국 호환성 없는 에러 코드와 표준을 잘 따르지 않는 상태 코드를 가진 `SQLException`만으로 `DB`에 독립적인 유연한 코드를 작성하는 것은 불가능에 가깝다.

## 4.2.2 DB 에러 코드 매핑을 통한 전환

## 4.2.3 DAO 인터페이스와 DataAccessException 계층구조

```java
public class UserDao {
    // ...
    public void add(final User user) throws DuplicateKeyException {
        this.jdbcTemplate.update(
                "insert into users (id, name, password) values (?, ?, ?)",
                user.getId(),
                user.getName(),
                user.getPassword()
        );
    }
    // ...
}
```

```java
public class UserDao {
    // ...
    public void add(final User user) throws DuplicateUserIdException {
        try {
            this.jdbcTemplate.update(
                    "insert into users (id, name, password) values (?, ?, ?)",
                    user.getId(),
                    user.getName(),
                    user.getPassword()
            );
        }
        catch (DuplicateKeyException e) {
            throw new DuplicateUserIdException(e);
        }
    }
    // ...
}
```

### DAO 인터페이스와 구현의 분리

```java
public interface UserDao {
    public void add(User user);
    // ...
}
```

```java
public interface UserDao {
    public void add(User user) throws SQLExcpetion;
    // ...
}
```

```java
public interface Dao {
    public void add(User user) throws PersistentException; // JPA
    public void add(User user) throws HibernateException; // Hibernate
    public void add(User user) throws JdoException; // JDO
}
```

### 데이터 액세스 예외 추상화와 DataAccessException 계층구조

## 4.2.4 기술에 독립적인 UserDao 만들기

### 인터페이스 적용

```java
public interface UserDao {
    void add(User user);
    User get(String id);
    List<User> getAll();
    void deleteAll();
    int getCount();
}
```

### 테스트 보완

### DataAccessException 활용 시 주의사항
