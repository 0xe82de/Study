# Contents

- [4.2.1 JDBC의 한계](#421-JDBC의-한계)
- [4.2.2 DB 에러 코드 매핑을 통한 전환](#422-DB-에러-코드-매핑을-통한-전환)
- [4.2.3 DAO 인터페이스와 DataAccessException 계층구조](#423-DAO-인터페이스와-DataAccessException-계층구조)
- [4.2.4 기술에 독립적인 UserDao 만들기](#424-기술에-독립적인-UserDao-만들기)

# 4.2 예외 전환

예외 전환의 목적은 다음과 같이 두 가지이다.

- `런타임 예외`로 포장해서 굳이 필요하지 않은 `catch/throws`문을 줄이는 것이다.
- 로우레벨의 예외를 의미 있고 추상화된 예외로 바꿔서 던지는 것이다.

스프링의 `JdbcTemplate`의 역할은 다음과 같다.

- `JdbcTemplate`이 던지는 `DataAccessException`은 `SQLException`을 `런타임 예외`로 포장한다. 이를 통해 애플리케이션 레벨에서는 복구가 불가능한 `SQLException` 예외에 대해 신경 스지 않도록 해주는 것이다.
- `DataAccessException`은 `SQLException`에 담긴 상세한 예외정보를 의미 있고 일관성 있는 예외로 전환해서 추상화해주려는 용도로도 쓰인다.

## 4.2.1 JDBC의 한계

`DB`별로 다른 `API`를 제공하고 이를 사용해야 한다고 가정해보자. `DB`가 바뀔 때마다 `DAO` 코드도 바뀔 것이다. 또한, 각각의 `API` 사용 방법도 익혀야 한다.

`JDBC`는 자바를 이용해 `DB`에 접근하는 방법을 추상화된 `API` 형태로 정의해놓고, 각 `DB` 업체가 `JDBC` 표준을 따라 만들어진 드라이버를 제공하게 해준다. 내부 구현은 다르지만 `JDBC`의 표준 인터페이스인 `Connection`, `Statement`, `ResultSet` 등을 통해 기능을 제공해주므로 자바 개발자들은 표준화된 `JDBC`의 `API`만 익숙해지면 `DB`의 종류에 상관없이 일관된 방법으로 프로그램을 개발할 수 있다. 인터페이스를 사용하는 객체지향 프로그래밍 방법의 장점을 잘 경험할 수 있는 것이 바로 `JDBC`다.

하지만 `DB` 종류에 상관없이 사용할 수 있는 데이터 액세스 코드를 작성하는 것은 어렵다. 현실적으로 `DB`를 자유롭게 바꾸어 사용할 수 있는 `DB` 프로그램을 작성하는 데는 두 가지 어려움이 있다.

### 비표준 SQL

첫 번째 문제는 `JDBC` 코드에서 사용하는 `SQL`이다. 대부분의 `DB`는 표준을 따르지 않는 비표준 문법과 기능을 제공하는데, 이러한 비표준 특정 `DB` 전용 문법이 폭넓게 사용되고 있다. 해당 `DB`의 특별한 기능을 사용하거나 최적화된 `SQL`을 만들 떄 유용하기 때문이다.

이렇게 작성된 비표준 `SQL`은 `DAO` 코드에 들어가고 해당 `DAO`는 특정 `DB`에 종속적인 코드가 된다. 다른 `DB`로 변경하려면 `DAO`에 담긴 `SQL`을 꽤 수정해야 할 것이다. 일반적으로 `DB`가 바뀌지 않고, 사용하는 `DB`에 최적화하는 것이 중요하므로 비표준 `SQL`을 거리낌없이 사용한다. 하지만 `DB`의 변경 가능성을 고려한다면 비표준 `SQL`은 큰 문제가 된다.

이 문제의 해결책을 생삭해보면, 호환 가능한 표준 `SQL`만 사용하거나 `DB`별로 별도의 `DAO`를 만들거나 `SQL`을 외부에 독립시켜서 `DB`에 따라 변경해 사용하도록 할 수 있다. 표준 `SQL`만을 사용할 경우 웹 프로그램에서 자주 필요로 하는 페이징 쿼리에서부터 문제가 되므로 표준 `SQL`은 해결채깅 될 수 없다. 따라서, `DB`별로 `DAO`를 만들거나 `SQL`을 외부로 독립시켜야 한다.

### 호환성 없는 SQLException의 DB 에러정보

두 번째 문제는 `SQLException`이다. `DB`를 사용하다가 발생할 수 있는 예외의 원인은 다양한데, 대표적으로 다음과 같은 원인이 있다.

- `SQL` 문법 오류
- `DB` 커넥션을 가져오지 못한 경우
- 존재하지 않는 테이블 또는 필드를 사용
- 키 중복
- 제약조건 위배
- 데드락

여기서 문제는 `DB`마다 `SQL`만 다른 것이 아니라 에러의 종류와 원인도 다르다는 것이다. 그래서 `JDBC`는 데이터 처리 중에 발생하는 다양한 예외를 `SQLException` 하나에 모두 담아버린다. 예외가 발생하는 원인은 `SQLException` 안에 담긴 에러 코드와 `SQL` 상태 정보를 참조해봐야 한다. 그런데, `DB` 벤더가 정의한 고유한 에러코드가 각각 다르기 때문에 `SQLException`의 `getErrorCode()`로 가져올 수 있는 `DB` 에러 코드는 `DB`별로 다르다.

앞서 작성한 `add()` 메서드에서는 새로운 사용자를 등록하다가 키가 중복되어 예외가 발생하는 경우를 확인하기 위하여 다음과 같은 방법을 사용했었다.

```java
if (e.getErrorCode() == MysqlErrorNumbers.ER_DUP_ENTRY) { /* ... */ }
```

위의 코드는 `MySQL` 전용 코드일 뿐이다. `DB`가 바뀐다면 위 코드는 기대한 대로 동작하지 못할 것이다. 그래서 `SQLException`은 예외가 발생했을 때의 `DB` 상태를 담은 `SQL` 상태정보를 부가적으로 제공하는데, `getSQLState()` 메서드로 예외상황에 대한 상태정보를 가져올 수 있다. 이 상태정보는 `DB`별로 달라지는 에러 코드를 대신할 수 있도록, `Open Group`의 `XOPEN SQL` 스펙에 정의된 `SQL 상태 코드를 따르도록 되어 있다.

`SQLException`이 이러한 상태 코드를 제공하는 이유는 `DB`에 독립적인 에러정보를 얻기 위해서다. 그런데 문제가 있다. `JDBC` 드라이버에서 `SQLException`을 담을 상태 코드를 정확하게 만들어주지 않는다. 결과적으로 이 `SQL` 상태 코드를 믿고 결과를 파악하는 것은 위험하다.

결국 호환성 없는 에러 코드와 표준을 잘 따르지 않는 상태 코드를 가진 `SQLException`만으로 `DB`에 독립적인 유연한 코드를 작성하는 것은 불가능에 가깝다.

## 4.2.2 DB 에러 코드 매핑을 통한 전환

`DB` 종류가 바뀌더라도 `DAO`를 수정하지 않으려면 위에서 언급한 두 가지 문제를 해결해야 한다. 여기서는 `SQLException`의 비표준 에러 코드와 `SQL` 상태정보에 대한 해결책을 알아보자.

`SQLException`에 담긴 `SQL` 상태 코드는 신뢰할 수 없으므로 더 이상 고려하지 않는다. 차라리 `DB` 업체별로 지원하는 `DB` 전용 에러 코드가 더 정확하다고 할 수 있다. `SQL` 상태 코드는 `JDBC` 드라이버를 만들 때 들어가는 것이므로 같은 `DB`라고 하더라도 드라이버를 만들 때마다 달라지기도 하지만, `DB` 에러 코드는 `DB`에서 직접 제공해주므로 버전이 올라가더라도 어느 정도 일관성이 유지된다.

해결 방법은 `DB`별 에러 코드를 참고해서 발생한 예외의 원인이 무엇인지 해석해주는 기능을 만드는 것이다. `DB`별로 에러 코드 값을 확인할 수 있다면, 키 중복 때문에 발생하는 `SQLException`을 `DuplicateKeyException`이라는 의미가 분명한 예외로 전환할 수 있다.

스프링은 `DataAccessException`이라는 `SQLException`을 대체할 수 있는 `런타임 예외`를 정의하고 있을 뿐 아니라 `DataAccessException`의 서브클래스로 세분화된 예외 클래스들을 정의하고 있다.

| 원인                                                                   | 예외 클래스                          |
| ---------------------------------------------------------------------- | ------------------------------------ |
| `SQL` 문법을 잘못 사용했을 때                                          | `BadSqlGrammerException`             |
| `DB` 커넥션을 가져오지 못했을 때                                       | `DataAccessResourceFailureException` |
| 데이터의 제약조건을 위배했거나 일관성을 지키지 않는 작업을 수행했을 때 | `DataIntegrityViolationException`    |
| 키가 중복되었을 때                                                     | `DuplicateKeyException`              |

이 외에도 데이터 액세스 작업 중에 발생할 수 있는 예외상황을 수십 가지 예외로 분류하고 이를 추상화해 정의한 다양한 예외 클래스르 제공한다.

문제는 `DB`마다 에러 코드가 제각각이라는 것이다. `DAO` 메서드나 `JdbcTemplate` 등에서 `DB`별로 에러 코드의 종류를 확인하는 것은 부담이 크다. 대신 스프링은 `DB`별 에러 코드를 분류해서 스프링이 정의한 예외 클래스와 매핑해놓은 에러 코드 매핑정보 테이블을 만들어두고 이를 이용한다.

`JdbcTemplate`은 `SQLException`을 단지 `런타임 예외`인 `DataAccessException`으로 포장하는 것이 아니라 `DB`의 에러 코드를 `DataAccessException` 계층구조의 클래스 중 하나로 매핑해준다. 전환되는 `JdbcTemplate`에서 던지는 예외는 모두 `DataAccessException`의 서브클래스 타입이다. 드라이버나 `DB` 메타정보를 참고해서 `DB` 종류를 확인하고 `DB`별로 미리 준비된 매핑정보를 참고해서 적절한 예외 클래스를 선택하므로 `DB`가 달라져도 같은 종류의 에러라면 동일한 예외를 받을 수 있는 것이다.

중복 키 에러를 따로 분류해서 예외처리를 했던 `add()` 메서드를 스프링의 `JdbcTemplate`으로 사용하도록 바꾸면 다음과 같이 수정할 수 있다.

```java
public class UserDao {
    // ...
    public void add(final User user) throws DuplicateKeyException {
        // ...
    }
    // ...
}
```

`JdbcTemplate`은 `체크 예외`인 `SQLException`을 `런타임 예외`인 `DataAccessException` 계층구조의 예외로 포장해주므로 `add()` 메서드에서 예외 포장을 위한 코드는 필요 없다. 또한, `DB`의 종류와 상관없이 중복 키로 인해 발생하는 에러는 `DataAccessException`의 서브클래스인 `DuplicateKeyException`으로 매핑돼서 던져진다.

`JdbcTemplate`을 이용한다면 `JDBC`에서 발생하는 `DB` 관련 예외는 거의 신경쓰지 않아도 된다.

그런데 중복 키 에러가 발생했을 때 애플리케이션에서 직접 정의한 예외를 발생시키고 싶을 수 있다. 이유는 개발 정책때문일 수 있고, `DuplicateKeyException`의 `런타임 예외`이기 때문에 예외처리를 강제하지 않는 것이 불안해서 그럴 수도 있다. 아무튼 `체크 예외`인 `DuplicateUserIdException`을 던지게 하고 싶다면 다음과 같이 스프링의 `DuplicateKeyException`을 전환해주는 코드를 `DAO` 코드에 작성하면 된다.

```java
public class UserDao {
    // ...
    public void add(final User user) throws DuplicateUserIdException {
        try {
            // ...
        }
        catch (DuplicateKeyException e) {
            throw new DuplicateUserIdException(e);
        }
    }
    // ...
}
```

시간이 지나고 `JDK 6.0` 이상을 사용하며, `JDBC 4.0`의 스펙을 충실히 따라 정확한 상태정보를 가지고 일관성 있는 예외를 만들어주는 `JDBC` 드라이버가 충분히 보급된다면 모르겠지만, 아직은 스프링의 에러 코드 매핑을 통한 `DataAccessException` 방식을 사용하는 것이 이상적이다.

## 4.2.3 DAO 인터페이스와 DataAccessException 계층구조

### DAO 인터페이스와 구현의 분리

```java
public interface UserDao {
    public void add(User user);
    // ...
}
```

```java
public interface UserDao {
    public void add(User user) throws SQLExcpetion;
    // ...
}
```

```java
public interface Dao {
    public void add(User user) throws PersistentException; // JPA
    public void add(User user) throws HibernateException; // Hibernate
    public void add(User user) throws JdoException; // JDO
}
```

### 데이터 액세스 예외 추상화와 DataAccessException 계층구조

## 4.2.4 기술에 독립적인 UserDao 만들기

### 인터페이스 적용

```java
public interface UserDao {
    void add(User user);
    User get(String id);
    List<User> getAll();
    void deleteAll();
    int getCount();
}
```

### 테스트 보완

### DataAccessException 활용 시 주의사항
