# Contents

- [4.1.1 초난감 예외처리](#411-초난감-예외처리)
- [4.1.2 예외의 종류와 특징](#412-예외의-종류와-특징)
- [4.1.3 예외처리 방법](#413-예외처리-방법)
- [4.1.4 예외처리 전략](#414-예외처리-전략)
- [4.1.5 SQLException은 어떻게 됐나?](#415-SQLException은-어떻게-됐나)

# 4.1 사라진 SQLException

3장에서 `JdbcTemplate`을 적용하면서 `deleteAll()` 메서드의 예외 처리를 지웠었다.

```java
public class UserDao {
    // ...
    public void deleteAll() { // 에외 처리를 하지 않고 있다.
        this.jdbcTemplate.update("delete from users");
    }
    // ...
}
```

`SQLException`은 `JDBC API`의 메서드들이 던지는 것이므로 당연히 있어야 하는데 어디로 간 것일까?

## 4.1.1 초난감 예외처리

먼저 개발자들의 코드에서 종종 발견되는 난감한 예외처리 방법을 알아보자.

### 예외 블랙홀

```java
try {
    // ...
} catch (SQLException e) {
}
```

위와 같이 `try/catch` 블럭으로 예외를 잡고 있지만 처리는 하지 않고 있다. 아무것도 하지 않고 넘어가는 것은 정말 위험한 일이다. 프로그램 실행 중에 어디선가 예외가 발생했는데 그것을 무시하고 계속 진행해버리기 때문이다. 결국 발생한 예외로 인해 예상치 못한 다른 문제를 일으킬 것이다. 아래과 같은 코드도 마찬가지로 위험한 코드다.

```java
try {
    // ...
} catch (SQLException e) {
    System.out.println(e);
}

try {
    // ...
} catch (SQLException e) {
    e.printStackTrace();
}
```

예외가 발생하였을 때 화면에 출력만 하는 것은 문제가 있다. 콘솔 로그를 누군가가 계속 모니터링하지 않는 한 이 예외 코드는 처리되지 않을 것이다.

예외를 처리할 때 반드시 지켜야 할 핵심 원칙은 한 가지다. 모든 예외는 적절하게 복구되든지, 작업을 중단시키고 운영자 또는 개발자에게 분명하게 통보되어야 한다.

굳이 예외를 잡아서 조치를 취할 방법이 없다면 잡지 말고 메서드 밖으로 던지고 자신을 호출한 코드에 예외처리 책임을 전가하는 것이 낫다.

### 무의미하고 무책임한 throws

```java
public void method1() throws Exception {
    method2();
    // ...
}

public void method2() throws Exception {
    method3();
    // ...
}

public void method3() throws Exception {
    // ...
}
```

위와 같이 메서드 선언에 `throws Exception`을 기계적으로 붙이는 것도 문제가 된다. 자신이 사용하려고 하는 메서드에 `throws Exception`이 선언되어 있다고 가정해보자. 이러한 메서드 선언에는 의미 있는 정보를 얻을 수 없다. 정말 실행 중에 예외적인 상황이 발생할 수 있다는 것인지, 그냥 습관적으로 복사해서 붙여놓은 것인지 알 수 없다. 결과적으로 적절한 처리를 통해 복구될 수 있는 예외상황도 제대로 다룰 수 있는 기회를 박탈당한다.

## 4.1.2 예외의 종류와 특징

예외처리에 관해서는 자바 개발자들 사이에서도 오랫동안 많은 논쟁이 있었는데, 가장 큰 이슈는 `체크 예외(checked exception)`라고 불리는 명시적인 처리가 필요한 예외를 사용하고 다루는 방법이다.

자바에서 `throw`를 통해 발생시킬 수 있는 예외는 크게 세 가지가 있다.

#### Error

`java.lang.Error` 클래스의 서브클래스들이다. `에러`는 시스템에 비정상적인 상황이 발생했을 경우에 사용된다. 애플리케이션 코드에서 잡으려고 해봤자 아무런 대응 방법이 없다. 따라서 시스템 레벨에서 특별한 작업을 하는 것이 아니라면 애플리케이션에서는 이런 `에러`에 대한 처리는 신경쓰지 말자.

#### Exception과 체크 예외

`java.lang.Exception` 클래스와 그 서브클래스로 정의되는 예외들은 `에러`와 달리 개발자들이 만든 애플리케이션 코드와 작업 중에 예외상황이 발생했을 경우에 사용된다. `Exception` 클래스는 다시 `체크 예외`와 `언체크 예외(unchecked exception)`로 구분되며, `체크 예외`는 `Exception` 클래스의 서브클래스이면서 `RuntimeException` 클래스를 상속하지 않은 것들이고, `언체크 예외`는 `RuntimeException`을 상속한 클래스들을 말한다.

일반적으로 예외라고 하면 `체크 예외`라고 생각해도 된다. `체크 예외`가 발생할 수 있는 메서드를 사용할 경우 `catcy` 문으로 잡든지, 다시 `throws`를 정의해서 메서드 밖으로 던져야 한다. 그렇지 않으면 컴파일 에러가 발생한다.

#### RuntimeException과 언체크/런타임 예외

`java.lang.RuntimeException` 클래스를 상속한 예외들은 명시적인 예외처리를 강제하지 않기 때문에 `언체크 예외`라고 불린다. 또는 `런타임 예외`라고도 한다. `에러`와 마찬가지로 `catch` 문으로 잡거나 `throws`로 선언하지 않아도 된다.

`런타임 예외`는 주로 프로그램의 오류가 있을 때 발생하도록 의도된 것들이며 대표적으로 `NullPointerException`, `IllegalArgumentException` 등이 있다.

## 4.1.3 예외처리 방법

### 예외 복구

### 예외처리 회피

### 예외 전환

## 4.1.4 예외처리 전략

### 런타임 예외의 보편화

### add() 메소드의 예외처리

### 애플리케이션 예외

## 4.1.5 SQLException은 어떻게 됐나?
