# Contents

- [4.1.1 초난감 예외처리](#411-초난감-예외처리)
- [4.1.2 예외의 종류와 특징](#412-예외의-종류와-특징)
- [4.1.3 예외처리 방법](#413-예외처리-방법)
- [4.1.4 예외처리 전략](#414-예외처리-전략)
- [4.1.5 SQLException은 어떻게 됐나?](#415-SQLException은-어떻게-됐나)

# 4.1 사라진 SQLException

3장에서 `JdbcTemplate`을 적용하면서 `deleteAll()` 메서드의 예외 처리를 지웠었다.

```java
public class UserDao {
    // ...
    public void deleteAll() { // 에외 처리를 하지 않고 있다.
        this.jdbcTemplate.update("delete from users");
    }
    // ...
}
```

`SQLException`은 `JDBC API`의 메서드들이 던지는 것이므로 당연히 있어야 하는데 어디로 간 것일까?

## 4.1.1 초난감 예외처리

먼저 개발자들의 코드에서 종종 발견되는 난감한 예외처리 방법을 알아보자.

### 예외 블랙홀

```java
try {
    // ...
} catch (SQLException e) {
}
```

위와 같이 `try/catch` 블럭으로 예외를 잡고 있지만 처리는 하지 않고 있다. 아무것도 하지 않고 넘어가는 것은 정말 위험한 일이다. 프로그램 실행 중에 어디선가 예외가 발생했는데 그것을 무시하고 계속 진행해버리기 때문이다. 결국 발생한 예외로 인해 예상치 못한 다른 문제를 일으킬 것이다. 아래과 같은 코드도 마찬가지로 위험한 코드다.

```java
try {
    // ...
} catch (SQLException e) {
    System.out.println(e);
}

try {
    // ...
} catch (SQLException e) {
    e.printStackTrace();
}
```

예외가 발생하였을 때 화면에 출력만 하는 것은 문제가 있다. 콘솔 로그를 누군가가 계속 모니터링하지 않는 한 이 예외 코드는 처리되지 않을 것이다.

예외를 처리할 때 반드시 지켜야 할 핵심 원칙은 한 가지다. 모든 예외는 적절하게 복구되든지, 작업을 중단시키고 운영자 또는 개발자에게 분명하게 통보되어야 한다.

굳이 예외를 잡아서 조치를 취할 방법이 없다면 잡지 말고 메서드 밖으로 던지고 자신을 호출한 코드에 예외처리 책임을 전가하는 것이 낫다.

### 무의미하고 무책임한 throws

```java
public void method1() throws Exception {
    method2();
    // ...
}

public void method2() throws Exception {
    method3();
    // ...
}

public void method3() throws Exception {
    // ...
}
```

위와 같이 메서드 선언에 `throws Exception`을 기계적으로 붙이는 것도 문제가 된다. 자신이 사용하려고 하는 메서드에 `throws Exception`이 선언되어 있다고 가정해보자. 이러한 메서드 선언에는 의미 있는 정보를 얻을 수 없다. 정말 실행 중에 예외적인 상황이 발생할 수 있다는 것인지, 그냥 습관적으로 복사해서 붙여놓은 것인지 알 수 없다. 결과적으로 적절한 처리를 통해 복구될 수 있는 예외상황도 제대로 다룰 수 있는 기회를 박탈당한다.

## 4.1.2 예외의 종류와 특징

## 4.1.3 예외처리 방법

### 예외 복구

### 예외처리 회피

### 예외 전환

## 4.1.4 예외처리 전략

### 런타임 예외의 보편화

### add() 메소드의 예외처리

### 애플리케이션 예외

## 4.1.5 SQLException은 어떻게 됐나?
