# Contents

- [2.3.1 JUnit 테스트 실행 방법](#231-JUnit-테스트-실행-방법)
- [2.3.2 테스트 결과의 일관성](#232-테스트-결과의-일관성)
- [2.3.3 포괄적인 테스트](#233-포괄적인-테스트)
- [2.3.4 테스트가 이끄는 개발](#234-테스트가-이끄는-개발)
- [2.3.5 테스트 코드 개선](#235-테스트-코드-개선)

# 2.3 개발자를 위한 테스팅 프레임워크 JUnit

`JUnit`은 자바의 표준 테스팅 프레임워크라고 불릴 만큼 폭넓게 사용되고 있다.

## 2.3.1 JUnit 테스트 실행 방법

### IDE

대부분의 자바 개발자가 사용하고 있는 사실상의 표준 자바 `IDE`인 이클립스는 오래전부터 `JUnit` 테스트를 지원하는 기능을 제공하고 있다.

이클립스가 지원하는 기능을 통해 확인할 수 있는 사항은 다음과 같다.

- 총 수행시간
- 실행한 테스트의 수
- 테스트 에러의 수
- 테스트 실패의 수
- 어떤 테스트를 실행하였는지
- 각 테스트 메서드와 클래스의 테스트 수행에 걸린 시간

### 빌드 툴

프로젝트의 빌드를 위해 `ANT` 또는 `메이븐(Maven)`과 같은 빌드 툴과 스크립트를 사용한다면, 빌드 툴에서 제공하는 `JUnit` 플러그인이나 태스트를 이용해 `JUnit` 테스트를 실행할 수 있다.

여러 개발자가 만든 코드를 통합해서 테스트를 수행해야 할 때는 서버에서 모든 코드를 가져와 빌드한 뒤에 테스트를 수행하는 것이 좋다. 빌드 스크립트를 이용해 `JUnit` 테스트를 실행하고 그 결과를 메일 등으로 통보받는 방법을 사용하면 된다.

## 2.3.2 테스트 결과의 일관성

지금까지 테스트를 진행했을 때는 `DB`의 테이블 데이터를 모두 삭제해줘야 했다. 여기서 생각해볼 문제는 테스트가 외부 상태에 따라 성공하기도 실패하기도 한다는 점이다. 코드에 변경사항이 없다면 테스트는 항상 동일한 결과를 내야 한다.

`UserDaoTest`의 문제는 이전 테스트 때문에 중복된 데이터가 있을 수 있다는 점이다. `addAndGet()` 테스트를 마치고 테스트가 등록한 사용자 정보를 삭제해서 테스트를 수행하기 이전 상태로 만들어주면 된다.

### deleteAll()의 getCount() 추가

`UserDao`에 두 가지 기능을 추가해보자.

#### deleteAll

첫 번째는 `deleteAll()` 메서드다. 테이블의 모든 레코드를 삭제해주는 기능을 가진다.

```java
public class UserDao {
    // ...
    public void deleteAll() throws SQLException {
        Connection c = dataSource.getConnection();

        PreparedStatement ps = c.prepareStatement("delete from users");
        ps.executeUpdate();

        ps.close();
        c.close();
    }
    // ..
}
```

#### getCount()

두 번째는 `getCount()` 메서드다. 테이블의 레코드 개수를 반환해준다.

```java
public class UserDao {
    // ...
    public int getCount() throws SQLException {
        Connection c = dataSource.getConnection();

        PreparedStatement ps = c.prepareStatement("select count(*) from users");

        ResultSet rs = ps.executeQuery();
        rs.next();
        int count = rs.getInt(1);

        rs.close();
        ps.close();
        c.close();

        return count;
    }
}
```

### deleteAll()과 getCount()의 테스트

새로운 기능을 추가했으니, 추가된 기능에 대한 테스트도 만들어야 한다.

`add()`, `get()` 메서드와 달리 `deleteAll()`, `getCount()` 메서드의 기능은 독립적으로 자동 실행되는 테스트를 만들기가 애매하다.

`deleteALl()` 메서드의 경우 수동으로 데이터를 넣고 `deleteAll()` 메서드를 실행해서 테이블에 남은 데이터가 있는지 확인해야 하는데, 사람이 확인을 해야 하니 반복적으로 실행할 수 있는 테스트 방법은 아니다. 그래서 여기서는 기존의 `addAndGet()` 테스트를 확장해서 테스트를 진행한다.

`addAndGet()` 테스트의 불편한 점은 실행 전에 수동으로 `DB`의 테이블 데이터를 모두 삭제해줘야 하는 점이다. `deleteAll()` 메서드를 이용하면 테이블의 모든 데이터를 삭제할 수 있으니 이 메서드를 테스트가 시작될 떄 실행해주는 것이 좋아보인다.

`deleteAll()` 메서드로 테이블 데이터가 잘 삭제되었는지 확인하기 위해 `getCount()` 메서드를 함께 적용해볼 수 있다. `deleteAll()` 메서드가 정상적으로 동작한다면 `getCount()` 메서드로 가져오는 레코드의 개수는 `0`이 될 것이다.

`getCount()` 메서드에 대한 검증 작업은 테이블에 데이터를 넣고 반환 결과가 `1`인지를 확인해보면 된다.

```java
public class UserDaoTest {
    // ...
    @Test
    public void addAndGet() throws SQLException {
        ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
        UserDao dao = context.getBean("userDao", UserDao.class);

        // 테이블 데이터를 모두 삭제한다.
        dao.deleteAll();
        // getCount() 메서드로 테이블의 레코드 개수를 가져와서 0과 비교한다.
        // 일치하면 테스트를 통과하고 다음 코드가 실행된다.
        assertThat(dao.getCount(), is(0));

        User user = new User();
        user.setId("gyumee");
        user.setName("박성철");
        user.setPassword("springno1");
        dao.add(user);
        // 위에서 데이터를 테이블에 넣었으니, getCount() 메서드의 기대 결과는 1 이다.
        // 마찬가지로 테스트를 통과하면 다음 코드가 실행된다.
        assertThat(dao.getCount(), is(1));

        User user2 = dao.get(user.getId());

        assertThat(user2.getName(), is(user.getName()));
        assertThat(user2.getPassword(), is(user.getPassword()));
    }
}
```

### 동일한 결과를 보장하는 테스트

테스트를 반복해서 실행해도 계속 성공할 것이다.

이와 같이 동일한 테스트 결과를 얻을 수 있는 다른 방법도 있다. `addAndGet()` 테스트를 마치기 직전에 테스트가 변경하거나 추가한 데이터를 모두 원래 상태로 만들어주는 것이다. 하지만 아직은 스프링의 기능을 충분히 살펴보지 못했으므로 바로 적용하기는 어렵고, 당분간은 이 방법을 사용한다.

단위 테스트는 항상 일관성 있는 결과가 보장되어야 한다는 점을 절대 잊어선 안 된다.

## 2.3.3 포괄적인 테스트

### getCount() 테스트

### addAndGet() 테스트 보완

### get() 예외조건에 대한 테스트

### 테스트를 성공시키기 위한 코드의 수정

### 포괄적인 테스트

## 2.3.4 테스트가 이끄는 개발

### 기능설계를 위한 테스트

### 테스트 주도 개발

## 2.3.5 테스트 코드 개선

### @Before

### 픽스처
