# Contents

- [2.4.1 테스트를 위한 애플리케이션 컨텍스트 관리](#241-테스트를-위한-애플리케이션-컨텍스트-관리)
- [2.4.2 DI와 테스트](#242-DI와-테스트)

# 2.4 스프링 테스트 적용

`@Before` 메서드는 테스트 메서드 개수만큼 실행이 되는데, 이 때 `애플리케이션 컨텍스트`도 반복되서 생성이 된다. `빈`이 많아지고 복잡해지면 `애플리케이션 컨텍스트` 생성에 적지 않은 시간이 걸릴 수 있다.

`애플리케이션 컨텍스트`가 생성될 때는 모든 `싱글톤 빈 오브젝트`를 초기화한다. 단순히 `빈` 오브젝트를 만드는 정도라면 상관없지만, 어떤 `빈`은 오브젝트가 생성될 때 자체적인 초기화 작업을 진행해서 제법 많은 시간을 필요로 하기 때문이다.

또 한 가지 문제는 애플리케이션 컨텍스트가 초기화될 때 어떤 `빈`은 독자적으로 많은 리소스를 할당하거나 독립적인 스레드를 띄우기도 한다는 점이다. 이 경우에 테스트를 마칠 때마다 `애플리케이션 컨텍스트` 내의 `빈`이 할당한 리소스 등을 정리해주지 않으면 다음 테스트에서 새로운 `애플리케이션 컨텍스트`가 생성되면서 문제가 발생할 수도 있다.

테스트는 가능한 한 독립적으로 매번 새로운 오브젝트를 만들어서 사용하는 것이 원칙이지만, `애플리케이션 컨텍스트`처럼 생성에 많은 시간과 자원이 소모되는 경우에는 테스트 전체가 공유하는 오브젝트를 만들기도 한다.

`JUnit`이 매번 테스트 클래스의 오브젝트를 새로 만들기 때문에 `애플리케이션 컨텍스트`를 오브젝트 레벨에 저장해두면 안 된다. `JUni`은 테스트 클래스 전체에 걸쳐 딱 한 번만 실행되는 `@BeforeClass` `static` 메서드를 지원한다. 이 메서드에서 `애플리케이션 컨텍스트`를 만들어 `static` 변수에 저장해두고 테스트 메서드에서 사용할 수 있다.

하지만 이보다는 스프링이 직접 제공하는 `애플리케이션 컨텍스트` 테스트 지원 기능을 사용하는 것이 더 편리하다.

## 2.4.1 테스트를 위한 애플리케이션 컨텍스트 관리

### 스프링 테스트 컨텍스트 프레임워크 적용

스프링 테스트 컨텍스트 프레임워크를 적용하기 위해 `UserDaoTest`를 다음과 같이 수정한다.

```java
@RunWith(SpringJUnit4ClassRunner.class) // 스프링의 테스트 컨텍스트 프레임워크의 JUnit 확장기능 지정
@ContextConfiguration(locations="/applicationContext.xml") // 테스트 컨텍스트가 자동으로 만들어줄 애플리케이션 컨텍스트의 위치 지정
public class UserDaoTest {
   @Autowired
   private ApplicationContext context; // 테스트 오브젝트가 생성되고 나면 스프링 테스트 컨텍스트에 의해 자동으로 값이 주입된다.
   // ...

    @Before
    public void setUp() {
        this.dao = context.getBean("userDao", UserDao.class);
        // ...
    }
    // ...
```

위의 코드에서 `context`를 초기화해주지 않기 때문에 `NullPointerException`이 발생한다고 생각할 수 있지만 정상적으로 테스트가 진행된다.

`@RunWith`는 `JUnit` 프레임워크의 테스트 실행 방법을 확장할 때 사용하는 애노테이션이다. `SprintJUnit4ClassRunner`라는 `JUnit`용 테스트 컨텍스트 프레임워크 확장 클래스를 지정해주면 `JUnit`이 테스트를 진행하는 중에 테스트가 사용할 `애플리케이션 컨텍스트`를 만들고 관리하는 작업을 진행해준다.

`@ContextConfiguration`은 자동으로 만들어줄 `애플리케이션 컨텍스트`의 설정파일 위치를 지정한 것이다.

### 테스트 메서드의 컨텍스트 공유

위의 코드에서 아래의 두 줄을 추가하고 테스트를 실행해보자.

```java
// ...
@Before
public void setUp() {
    System.out.println(this.context);
    System.out.println(this);
}
/* 출력 결과
org.springframework.context.support.GenericApplicationContext@79ca92b9: startup date [Wed Oct 06 19:37:04 KST 2021]; root of context hierarchy
springbook.user.dao.UserDaoTest@2f953efd
org.springframework.context.support.GenericApplicationContext@79ca92b9: startup date [Wed Oct 06 19:37:04 KST 2021]; root of context hierarchy
springbook.user.dao.UserDaoTest@6e15fe2
org.springframework.context.support.GenericApplicationContext@79ca92b9: startup date [Wed Oct 06 19:37:04 KST 2021]; root of context hierarchy
springbook.user.dao.UserDaoTest@12a94400
*/
```

`@Before` 애노테이션이 붙어 있는 `setUp` 메서드는 테스트 메서드들이 실행되기 전에 한 번씩 실행된다.

위 코드의 결과를 보면 `this.context`의 결과(`@79ca92b9`)는 모두 동일함을 알 수 있다. 하나의 `애플리케이션 컨텍스트`가 만들어져 모든 테스트 메서드에서 사용되고 있는 것이다.

하지만 `UserDaoTest`의 결과는 매번 주소 값이 다르다. `JUnit`은 테스트 메서드를 실행할 때마다 새로운 테스트 오브젝트를 생성하기 때문이다.

- `@2f953efd`
- `@6e15fe2`
- `@12a94400`

`context` 변수에 동일한 `애플리케이션 컨텍스트`가 들어 있는 이유는 스프링의 `JUnit` 확장 기능이 테스트가 실행되기 전에 딱 한 번 `애플리케이션 컨텍스트`를 만들어두고, 테스트 오브젝트가 생성될 때마다 특별한 방법을 이용해 `애플리케이션 컨텍스트` 자신을 테스트 오브젝트의 특정 필드에 주입해주기 때문이다.

스프링이 `애플리케이션 컨텍스트`를 테스트 개수에 상관없이 한 번만 만들기 때문에 테스트 수행 속도는 매우 빨라지게 된다. 첫 번째 테스트의 수행 시간이 오래 걸리는데, 처음 실행될 때 최초로 `애플리케이션 컨텍스트`를 생성하기 때문이다.

### 테스트 클래스의 컨텍스트 공유

스프링 테스트 컨텍스트 프레임워크는 테스트 클래스 간에도 `애플리케이션 컨텍스트`를 공유하게 해준다. 다음과 같이 두 개의 테스트 클래스가 같은 설정파일을 사용하는 경우에는 테스트 수행 중에 단 한 개의 `애플리케이션 컨텍스트`만 만들어지고, 두 테스트 클래스의 모든 메서드가 하나의 `애플리케이션 컨텍스트`를 공유하게 된다.

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations="/applicationContext.xml")
public class UserDatoTest { /* ... */ }

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations="/applicationContext.xml")
public class GroupDaoTest { /* ... */ }
```

### @Autowired

`@Autowired`는 스프링의 `DI`에 사용되는 특별한 애노테이션이다. `@Autowired`가 붙은 인스턴스 변수가 있으면, 테스트 컨텍스트 프레임워크는 변수 타입과 일치하는 컨텍스트 내의 `빈`을 찾는다. 타입이 일치하는 `빈`이 있으면 인스턴스 변수에 주입해준다. 또 별도의 `DI` 설정 없이 필드의 타입정보를 이용해 `빈`을 자동으로 가져올 수 있는데, 이런 방법을 타입에 의한 `자동와이어링`이라고 한다.

현재까지의 테스트 코드에서는 `applicationContext.xml` 파일에 정의된 `빈`이 아니라, `ApplicationContext`라는 타입의 변수에 `@Autowired`를 붙였는데 `애플리케이션 컨텍스트`가 `DI`됐다. `ApplicationContext` 또한 `빈`이기 때문이다. 스프링은 `애플리케이션 컨텍스트`를 초기화할 때 자기 자신도 `빈`으로 등록한다. 따라서 `애플리케이션 컨텍스트`에는 `ApplicationContext` 타입의 `빈`이 존재하는 것이고, `DI`도 가능한 것이다.

`@Autowired`를 이용해 `애플리케이션 컨텍스트`가 가지고 있는 `빈`을 `DI` 받을 수 있다면 굳이 `getBean()` 메서드를 사용하는 것이 아니라, 아예 `UserDao 빈`을 직접 `DI` 받을 수 있다.

```java
// ...
public class UserDaoTest {
    // 삭제 -> @Autowired
    // 삭제 -> private ApplicationContext context;
    @Autowired
    UserDao dao;
    // ...
```

위와 같이 `ApplicationContext` 타입의 인스턴스 변수를 없애고 `UserDao` 인스턴스 변수에 `@Autowired`를 붙여준다. `애플리케이션 컨텍스트`를 `DI` 받아서 `DL` 방식(`getBean()`)으로 `UserDao`를 가져오는 것보다 코드가 깔끔해졌다. 번외로, `XML`에 `dataSource`라는 이름으로 등록한 `SimpleDriverDataSource` 타입의 `빈`을 가져오고 싶다면, 다음과 같이 인스턴스 변수를 추가해주기만 하면 된다.

```java
@Autowired
SimpleDriverDataSource dataSource;
```

`@Autowired`는 변수에 할당할 수 있는 타입을 가진 `빈`을 자동으로 찾는다. 즉, `SimpleDriverDataSource` 클래스 타입은 물론이고, 인터페이스인 `DataSource` 타입으로 변수를 선언해도 된다.

단, `@Autowired`는 같은 타입의 `빈`이 두 개 이상 있는 경우에는 타입만으로 어떤 `빈`을 가져올지 결정할 수 없다. 예를 들어, `DataSource` 타입의 `빈`이 두 개 이상 설정되어 있다면 다음과 같은 선언은 문제가 될 수 있다.

```java
@Autowired
DataSource dataSource;
```

`@Autowired`는 같은 타입의 `빈`이 두 개 이상일 때는 변수의 이름으로 찾는다. 예를 들어, 변수 두 개의 이름이 각각 `dataSource`, `dataSource2`이라면 `dataSource 빈`이 주입될 것이다. 변수 이름으로도 `빈`을 찾을 수 없는 경우에는 예외가 발생한다.

그런데 인터페이스인 `DataSource` 타입과 클래스인 `SimpleDriverDataSource` 타입 중 어느 타입으로 선언하는 것이 좋을까? 이것은 테스트에서 `빈`을 어떤 용도로 사용하느냐에 따라 다르다.

단순히 `DataSource`에 정의된 메서드를 테스트에서 사용한다면 `DataSource` 타입으로 받는 것이 좋다. `UserDao`의 `DI`용 수정자 메서드가 `DataSource` 타입의 파라미터를 가진 것과 같은 이유다. `DataSource`로 선언해두면 `dataSource 빈`의 구현 클래스를 변경하더라도 테스트 코드를 수정할 필요가 없다.

`SimpleDriverDataSource` 타입의 오브젝트 자체에 관심이 있는 경우에는 `SimpleDriverDataSource` 타입으로 선언해야 한다. 예를 들어 `XML`에서 프로퍼티로 설정한 `DB` 연결정보를 확인해야 하거나 `SimpleDriverDataSource` 클래스의 메서드를 직접 이용해서 테스트를 해야할 때도 있다.

## 2.4.2 DI와 테스트

### 테스트 코드에 의한 DI

### 테스트를 위한 별도의 DI 설정

### 컨테이너 없는 DI 테스트

### DI를 이용한 테스트 방법 선택
