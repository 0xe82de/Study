# Contents

- [1.4.1 오브젝트 팩토리](#141-오브젝트-팩토리)
- [1.4.2 오브젝트 팩토리의 활용](#142-오브젝트-팩토리의-활용)
- [1.4.3 제어권의 이전을 통한 제어관계 역전](#143-제어권의-이전을-통한-제어관계-역전)

# 1.4 제어의 역전(IoC)

## 1.4.1 오브젝트 팩토리

```java
public class UserDaoTest {
    public static void main(String[] args) throws ClassNotFoundException, SQLException {
        // DB 커넥션 생성
        ConnectionMaker connectionMaker = new DConnectionMaker();

        // UserDao 생성자로 DB 커넥션 오브젝트 전달
        UserDao userDao = new UserDao(connectionMaker);

        // ... 테스트 작업
    }
}
```

`UserDaoTest`는 `UserDao`가 잘 동작하는지 테스트하는 클래스이다. 그런데, 코드를 보면 `DB` 커넥션을 생성하는 코드도 포함되어 있는 것을 알 수 잇다. 이 또한, 분리를 해줄 필요가 있다.

### 팩토리

`DB` 커넥션을 수행하는 오브젝트를 생성하고, 이 오브젝트를 반환해주면 된다. 이런 일을 수행하는 오브젝트를 `팩토리(factory)`라고 부른다.

```java
// dao.DaoFactory.java
public class DaoFactory {
    public UserDao userDao() {
        ConnectionMaker connectionMaker = new DConnectionMaker();
        UserDao userDao = new UserDao(connectionMaker);
        return userDao;
    }
}

// dao.UserDaoTest.java
public class UserDaoTest {
    public static void main(String[] args) throws ClassNotFoundException, SQLException {
        // DaoFactory 오브젝트를 생성하고, 메서드 userDao()를 호출해서 UserDao() 오브젝트를 가지고 온다.
        UserDao dao = new DaoFactory().userDao();

        // ... 테스트 작업
    }
}
```

위와 같이 `DaoFactory` 클래의 `userDao()` 메서드는 `DB` 커넥션을 수행하는 오브젝트 `connectionMaker`로 `데이터 액세스`를 수행하는 `userDao` 오브젝트를 만들고, `userDao` 오브젝트를 반환한다. `UserDaoTest`의 `main` 메서드에서는 반환받은 `UserDao` 오브젝트로 테스트를 하기만 하면 된다.

### 설계도로서의 팩토리

여기까지 분리된 오브젝트들의 역할은 다음과 같다.

| 오브젝트        | 역할                        |
| --------------- | --------------------------- |
| UserDao         | 데이터 액세스               |
| ConnectionMaker | DB 커넥션                   |
| DaoFactory      | 오브젝트의 구성과 관계 정의 |

`UserDao`와 `ConnectionMaker`는 실질적인 로직을 담당하는 컴포넌트이고, `DaoFactory`는 애플리케이션을 구성하는 컴포넌트의 구조와 관계를 정의한 설계도와 같다.

## 1.4.2 오브젝트 팩토리의 활용

위에서 작성한 `DaoFactory`는 약간의 문제가 있다.

만약 `UserDao` 뿐만 아니라 새로운 `Dao` 클래스가 늘어난다면(`AccountDao`, `MessageDao` 등) 아래와 같이 `ConnectionMaker` 오브젝트를 생성해주는 중복된 코드(여기서는 `new DConnectionMaker()`)가 발생하게 된다. 이렇게 되면 `DConnectionMaker()`를 사용하지 않고 `DConnetionMaker2()`를 사용한다면 모든 메서드를 수정해줘야 한다.

```java
public class DaoFactory {
    public UserDao userDao() {
        return new UserDao(new DConnectionMaker());
    }

    public AccountDao accountDao() {
        return new AccountDao(new DConnectionMaker());
    }

    public MessageDao messageDao() {
        return new MessageDao(new DConnectionMaker());
    }
}
```

중복된 코드를 해결하기 위해 역시 분리를 해볼 수 있다. `ConnectionMaker`의 구현 클래스를 결정하고 오브젝트를 생성하는 코드를 별도의 메서드로 추출하는 것이다.

```java
public class DaoFactory {
    public UserDao userDao() {
        return new UserDao(connectionMaker());
    }

    public AccountDao accountDao() {
        return new AccountDao(connectionMaker());
    }

    public MessageDao messageDao() {
        return new MessageDao(connectionMaker());
    }

    // ConnectionMaker의 구현 클래스를 결정하고 오브젝트를 생성해서 반환한다.
    public ConnectionMaker connectionMaker() {
        return new DConnectionMaker();
    }
}
```

위와 같이 `connectionMaker()` 메서드를 작성해서 `ConnectionMaker`의 구현 클래스를 결정하고 오브젝트를 반환해주면 된다. 만약 구현 클래스가 바뀌면 `connectionMaker()` 메서드의 코드만 수정해주면 된다.

## 1.4.3 제어권의 이전을 통한 제어관계 역전
