# Contents

- [1.6.1 싱글톤 레지스트리로서의 애플리케이션 컨텍스트](#161-싱글톤-레지스트리로서의-애플리케이션-컨텍스트)
- [1.6.2 싱글톤 오브젝트의 상태](#162-싱글톤-오브젝트의-상태)
- [1.6.3 스프링 빈의 스코프](#163-스프링-빈의-스코프)

# 1.6 싱글톤 레지스트리와 오브젝트 스코프

`애플리케이션 컨텍스트`는 기존의 `DaoFactory`와는 중요한 차이점이 있다. `애플리케이션 컨텍스트`로 반환받는 오브젝트는 항상 동일하다는 것이다.

```java
public class DaoFactory {
    public static void main(String[] args) {
        DaoFactory factory = new DaoFactory();
        UserDao dao1 = factory.userDao();
        UserDao dao2 = factory.userDao();

        System.out.println(dao1); // springbook.user.dao.UserDao@5ebec15
        System.out.println(dao2); // springbook.user.dao.UserDao@21bcffb5

        ApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class);
        UserDao dao3 = context.getBean("userDao", UserDao.class);
        UserDao dao4 = context.getBean("userDao", UserDao.class);

        System.out.println(dao3); // springbook.user.dao.UserDao@14555e0a
        System.out.println(dao4); // springbook.user.dao.UserDao@14555e0a
    }
}
```

위의 코드와 같이 작성하고 실행하면 `DaoFactory` 오브젝트로 `UserDao` 오브젝트를 반환받으면 항상 다른 오브젝트가 반환되는 것을 확인할 수 있다. 그에 반해, `ApplicationConetext` 오브젝트로 `UserDao` 오브젝트를 반환받으면 항상 동일한 오브젝트가 반환됨을 알 수 있다. 왜 이런지 알아보자.

## 1.6.1 싱글톤 레지스트리로서의 애플리케이션 컨텍스트

`애플리케이션 컨텍스트`는 `싱글톤`을 저장하고 관리하는 `싱글톤 레지스트리(singleton registry)`이기도 하다.

스프링은 기본적으로 별다른 설정을 하지 앓으면 `빈` 오브젝트를 모두 `싱글톤`으로 생성한다. 이 `싱글톤`은 디자인 패턴의 `싱글톤 패턴`과 비슷한 개념이지만 구현 방법은 확연히 다르다.

### 서버 애플리케이션과 싱글톤

스프링이 `빈`을 `싱글톤`으로 만드는 이유는 스프링이 주로 적용되는 대상이 자바 엔터프라이즈 기술을 사용하는 서버환경이기 때문이다.

스프링이 처음 설계되었던 대규모의 엔터프라이즈 서버환경은 높은 성능이 요구되는 환경이었다. 매번 클라이언트에서 요청이 올 때마다 각 로직을 담당하는 오브젝트 5개가 생성된다고 가정하고, 초당 500개의 요청이 들어온다면 한 시간이면 9백만 개의 오브젝트가 생성된다. 이 정도의 부하는 서버가 감당하기 힘들다. 따라서, 엔터프라이즈 분야에서는 `서비스 오브젝트`라는 개념을 일찍부터 사용해왔다.

`서블릿`은 자바 엔터프라이즈 기술의 가장 기본이 되는 `서비스 오브젝트`라고 할 수 있는데, `서블릿`은 대부분의 멀티스레드 환경에서 `싱글톤`으로 동작한다. `서블릿` 클래스당 하나의 오브젝트만 생성하고, 사용자의 요청을 처리하는 여러 스레드에서 하나의 오브젝트를 공유해서 사용한다.

이렇게 애플리케이션 안에 한 개의 오브젝트만 생성해서 사용하는 것이 `싱글톤` 패턴의 원리다. 서버환경에서는 서비스 싱글톤의 사용이 권장된다.

하지만, 디자인 패턴에 소개된 `싱글톤` 패턴은 사용하기가 까다롭고 여러 문제가 있다. 그래서 `안티패턴(anti pattern)`이라고 부르는 사람도 있다.

### 싱글톤 패턴의 한계

자바에서 싱글톤을 구현하는 방법은 보통 다음과 같다.

- 생성자의 접근제한자를 `private`으로 하여 외부에서 오브젝트를 생성하지 못하도록 한다.
- 생성된 `싱글톤` 오브젝트를 저장할 수 있는 자신과 같은 타입의 `static` 필드를 정의한다.
- `static` 팩토리 메서드인 `getInstance()`를 만들고 이 메서드가 최초로 호출되는 시점에서 한 번만 오브젝트를 생성하고 `static` 필드에 저장된다. 또는 `static` 필드의 초기값으로 오브젝트를 미리 생성해줄 수도 있다.
- `싱글톤` 오브젝트가 생성된 후에는 `getInstance()` 메서드로 `static` 필드에 저장된 오브젝트를 반환해준다.

전형적인 `싱글톤` 패턴을 적용한다면 `UserDao`는 아래와 같은 모습이 될 것이다.

```java
public class UserDao {
    private static UserDao INSTANCE;

    private UserDao(ConnectionMaker connectionMaker) {
        this.connectionMaker = connectionMaker;
    }

    public static synchronized UserDao getInstance() {
        if (INSTANCE == null) INSTANCE = new UserDao(???);
        return INSTANCE;
    }
}
```

위의 코드처럼 `싱글톤` 패턴을 적용하면 `DaoFactory`에서 `UserDao`를 생성하여 `ConnectionMaker` 오브젝트를 넣어주는게 불가능해진다. 왜냐하면, `UserDao`의 생성자의 접근제한자가 `private`이기 때문이다. 일반적으로 `싱글톤` 패턴 구현 방식에는 다음과 같은 문제가 있다.

#### private 생성자를 갖고 있기 때문에 상속할 수 없다

`싱글톤` 패턴은 생성자를 `private`으로 제한하기 때문에 다른 생성자가 없다면 상속이 불가능하다. 객체지향의 장점인 상속과 다형성을 적용할 수 없다.

기술적인 서비스만 제공한다면 상관없겠지만, 애플리케이션의 로직을 담고 있는 일반 오브젝트의 경우 `싱글톤`으로 만들었을 때 겍체지향적인 설계의 장점을 적용하기가 어렵다는 점은 심각한 문제다. 또한, 객체지향의 특징이 적용되지 않는 `static` 필드와 메서드를 사용하는 것도 역시 동일한 문제를 발생시킨다.

#### 싱글톤은 테스트하기가 힘들다

`싱글톤`은 테스트하기가 어렵거나 테스트 방법에 따라 아예 테스트가 불가능하다.

- `싱글톤`은 만들어지는 방식이 제한적이기 때문에 테스트에서 사용될 때 목 오브젝트 등으로 대체하기가 힘들다.
- `싱글톤`은 초기화 과정에서 생성자 등을 통해 사용할 오브젝트를 다이내믹하게 주입하기도 힘들다.

따라서, 필요한 오브젝트는 직접 오브젝트를 만들어서 사용해야 하는데, 이런 경우 테스트용 오브젝트로 대체하기가 힘들다.

#### 서버환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다

서버에서 클래스 로더를 어떻게 구성하고 있느냐에 따라서 `싱글톤` 클래스임에도 하나 이상의 오브젝트가 만들어질 수 있다.

즉, 자바 언어를 이용한 `싱글톤` 패턴 기법은 서버환경에서는 보장되지 않는 것이다. 여러 개의 `JVM`에 분산되어서 설치가 되는 경우에도 각각 독립적으로 오브젝트가 생성되므로 `싱글톤`으로서의 가치가 떨어진다.

#### 싱글톤의 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다

`싱글톤`은 사용하는 클라이언트가 정해져 있지 않다.

`static` 메서드로 언제든 `싱글톤`에 접근할 수 있으므로 애플리케이션 어디서나 사용될 수 있고, `전역 상태(global state)`로 사용되기 쉽다.

### 싱글톤 레지스트리

스프링은 서버환경에서 `싱글톤`이 만들어져서 `서비스 오브젝트` 방식으로 사용되는 것은 적극 지지한다.

자바의 기본적인 `싱글톤` 패턴의 구현 방식은 여러 단점이 있으므로, 스프링은 직접 `싱글톤` 형태의 오브젝트를 만들고 관리하는 기능을 제공한다. 바로 `싱글톤 레지스트리(singleton registry)`다.

`싱글톤 레지스트리`의 장점은 `static` 메서드와 `private` 생성자를 사용해야하는 비정상적인 클래스가 아니라 평범한 자바 클래스를 싱글톤으로 활요하게 해준다는 점이다.

오브젝트 생성에 관한 모든 권한은 `IoC` 기능을 제공하는 `애플리케이션 컨텍스트`에 있기 때문에, 평범한 자바 클래스라도 `IoC` 방식의 컨테이너를 사용해서 생성과 관계설정, 사용 등에 대한 제어권을 컨테이너에게 넘기면 `싱글톤` 방식으로 만들어져 관리되게 할 수 있다.

`싱글톤 레지스트리`는 다음과 같은 이점을 추가로 제공한다.

- `싱글톤` 방식으로 사용될 애플리케이션 클래스도 `public` 생성자를 가질 수 있다. 따라서, 테스트 환경에서 자유롭게 오브젝트를 생성하거나, 테스트를 위한 목 오브젝트로 대체하는 것도 간단하다. `DaoFactory`에서 `UserDao`에 `ConnectionMaker` 오브젝트를 넣어주듯이, 생성자 파라미터를 이용해서 사용할 오브젝트를 넣어줄 수도 있다.
- `싱글톤` 패턴을 제외한 스프링이 지지하는 객체지향적인 설계 방식과 원칙, 디자인 패턴 등을 적용하는 데 제약이 없다.

## 1.6.2 싱글톤 오브젝트의 상태

## 1.6.3 스프링 빈의 스코프
