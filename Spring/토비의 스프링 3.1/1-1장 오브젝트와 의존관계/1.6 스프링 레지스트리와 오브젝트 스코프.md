# Contents

- [1.6.1 싱글톤 레지스트리로서의 애플리케이션 컨텍스트](#161-싱글톤-레지스트리로서의-애플리케이션-컨텍스트)
- [1.6.2 싱글톤 오브젝트의 상태](#162-싱글톤-오브젝트의-상태)
- [1.6.3 스프링 빈의 스코프](#163-스프링-빈의-스코프)

# 1.6 싱글톤 레지스트리와 오브젝트 스코프

`애플리케이션 컨텍스트`는 기존의 `DaoFactory`와는 중요한 차이점이 있다. `애플리케이션 컨텍스트`로 반환받는 오브젝트는 항상 동일하다는 것이다.

```java
public class DaoFactory {
    public static void main(String[] args) {
        DaoFactory factory = new DaoFactory();
        UserDao dao1 = factory.userDao();
        UserDao dao2 = factory.userDao();

        System.out.println(dao1); // springbook.user.dao.UserDao@5ebec15
        System.out.println(dao2); // springbook.user.dao.UserDao@21bcffb5

        ApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class);
        UserDao dao3 = context.getBean("userDao", UserDao.class);
        UserDao dao4 = context.getBean("userDao", UserDao.class);

        System.out.println(dao3); // springbook.user.dao.UserDao@14555e0a
        System.out.println(dao4); // springbook.user.dao.UserDao@14555e0a
    }
}
```

위의 코드와 같이 작성하고 실행하면 `DaoFactory` 오브젝트로 `UserDao` 오브젝트를 반환받으면 항상 다른 오브젝트가 반환되는 것을 확인할 수 있다. 그에 반해, `ApplicationConetext` 오브젝트로 `UserDao` 오브젝트를 반환받으면 항상 동일한 오브젝트가 반환됨을 알 수 있다. 왜 이런지 알아보자.

## 1.6.1 싱글톤 레지스트리로서의 애플리케이션 컨텍스트

`애플리케이션 컨텍스트`는 `싱글톤`을 저장하고 관리하는 `싱글톤 레지스트리(singleton registry)`이기도 하다.

스프링은 기본적으로 별다른 설정을 하지 앓으면 `빈` 오브젝트를 모두 `싱글톤`으로 생성한다. 이 `싱글톤`은 디자인 패턴의 `싱글톤 패턴`과 비슷한 개념이지만 구현 방법은 확연히 다르다.

### 서버 애플리케이션과 싱글톤

스프링이 `빈`을 `싱글톤`으로 만드는 이유는 스프링이 주로 적용되는 대상이 자바 엔터프라이즈 기술을 사용하는 서버환경이기 때문이다.

스프링이 처음 설계되었던 대규모의 엔터프라이즈 서버환경은 높은 성능이 요구되는 환경이었다. 매번 클라이언트에서 요청이 올 때마다 각 로직을 담당하는 오브젝트 5개가 생성된다고 가정하고, 초당 500개의 요청이 들어온다면 한 시간이면 9백만 개의 오브젝트가 생성된다. 이 정도의 부하는 서버가 감당하기 힘들다. 따라서, 엔터프라이즈 분야에서는 `서비스 오브젝트`라는 개념을 일찍부터 사용해왔다.

`서블릿`은 자바 엔터프라이즈 기술의 가장 기본이 되는 `서비스 오브젝트`라고 할 수 있는데, `서블릿`은 대부분의 멀티스레드 환경에서 `싱글톤`으로 동작한다. `서블릿` 클래스당 하나의 오브젝트만 생성하고, 사용자의 요청을 처리하는 여러 스레드에서 하나의 오브젝트를 공유해서 사용한다.

이렇게 애플리케이션 안에 한 개의 오브젝트만 생성해서 사용하는 것이 `싱글톤` 패턴의 원리다. 서버환경에서는 서비스 싱글톤의 사용이 권장된다.

하지만, 디자인 패턴에 소개된 `싱글톤` 패턴은 사용하기가 까다롭고 여러 문제가 있다. 그래서 `안티패턴(anti pattern)`이라고 부르는 사람도 있다.

### 싱글톤 패턴의 한계

자바에서 싱글톤을 구현하는 방법은 보통 다음과 같다.

- 생성자의 접근제한자를 `private`으로 하여 외부에서 오브젝트를 생성하지 못하도록 한다.
- 생성된 `싱글톤` 오브젝트를 저장할 수 있는 자신과 같은 타입의 `static` 필드를 정의한다.
- `static` 팩토리 메서드인 `getInstance()`를 만들고 이 메서드가 최초로 호출되는 시점에서 한 번만 오브젝트를 생성하고 `static` 필드에 저장된다. 또는 `static` 필드의 초기값으로 오브젝트를 미리 생성해줄 수도 있다.
- `싱글톤` 오브젝트가 생성된 후에는 `getInstance()` 메서드로 `static` 필드에 저장된 오브젝트를 반환해준다.

전형적인 `싱글톤` 패턴을 적용한다면 `UserDao`는 아래와 같은 모습이 될 것이다.

```java
public class UserDao {
    private static UserDao INSTANCE;

    private UserDao(ConnectionMaker connectionMaker) {
        this.connectionMaker = connectionMaker;
    }

    public static synchronized UserDao getInstance() {
        if (INSTANCE == null) INSTANCE = new UserDao(???);
        return INSTANCE;
    }
}
```

위의 코드처럼 `싱글톤` 패턴을 적용하면 `DaoFactory`에서 `UserDao`를 생성하여 `ConnectionMaker` 오브젝트를 넣어주는게 불가능해진다. 왜냐하면, `UserDao`의 생성자의 접근제한자가 `private`이기 때문이다. 일반적으로 `싱글톤` 패턴 구현 방식에는 다음과 같은 문제가 있다.

#### private 생성자를 갖고 있기 때문에 상속할 수 없다

`싱글톤` 패턴은 생성자를 `private`으로 제한하기 때문에 다른 생성자가 없다면 상속이 불가능하다. 객체지향의 장점인 상속과 다형성을 적용할 수 없다.

기술적인 서비스만 제공한다면 상관없겠지만, 애플리케이션의 로직을 담고 있는 일반 오브젝트의 경우 `싱글톤`으로 만들었을 때 겍체지향적인 설계의 장점을 적용하기가 어렵다는 점은 심각한 문제다. 또한, 객체지향의 특징이 적용되지 않는 `static` 필드와 메서드를 사용하는 것도 역시 동일한 문제를 발생시킨다.

#### 싱글톤은 테스트하기가 힘들다

`싱글톤`은 테스트하기가 어렵거나 테스트 방법에 따라 아예 테스트가 불가능하다.

- `싱글톤`은 만들어지는 방식이 제한적이기 때문에 테스트에서 사용될 때 목 오브젝트 등으로 대체하기가 힘들다.
- `싱글톤`은 초기화 과정에서 생성자 등을 통해 사용할 오브젝트를 다이내믹하게 주입하기도 힘들다.

따라서, 필요한 오브젝트는 직접 오브젝트를 만들어서 사용해야 하는데, 이런 경우 테스트용 오브젝트로 대체하기가 힘들다.

#### 서버환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다

서버에서 클래스 로더를 어떻게 구성하고 있느냐에 따라서 `싱글톤` 클래스임에도 하나 이상의 오브젝트가 만들어질 수 있다.

즉, 자바 언어를 이용한 `싱글톤` 패턴 기법은 서버환경에서는 보장되지 않는 것이다. 여러 개의 `JVM`에 분산되어서 설치가 되는 경우에도 각각 독립적으로 오브젝트가 생성되므로 `싱글톤`으로서의 가치가 떨어진다.

#### 싱글톤의 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다

`싱글톤`은 사용하는 클라이언트가 정해져 있지 않다.

`static` 메서드로 언제든 `싱글톤`에 접근할 수 있으므로 애플리케이션 어디서나 사용될 수 있고, `전역 상태(global state)`로 사용되기 쉽다.

### 싱글톤 레지스트리

스프링은 서버환경에서 `싱글톤`이 만들어져서 `서비스 오브젝트` 방식으로 사용되는 것은 적극 지지한다.

자바의 기본적인 `싱글톤` 패턴의 구현 방식은 여러 단점이 있으므로, 스프링은 직접 `싱글톤` 형태의 오브젝트를 만들고 관리하는 기능을 제공한다. 바로 `싱글톤 레지스트리(singleton registry)`다.

`싱글톤 레지스트리`의 장점은 `static` 메서드와 `private` 생성자를 사용해야하는 비정상적인 클래스가 아니라 평범한 자바 클래스를 싱글톤으로 활요하게 해준다는 점이다.

오브젝트 생성에 관한 모든 권한은 `IoC` 기능을 제공하는 `애플리케이션 컨텍스트`에 있기 때문에, 평범한 자바 클래스라도 `IoC` 방식의 컨테이너를 사용해서 생성과 관계설정, 사용 등에 대한 제어권을 컨테이너에게 넘기면 `싱글톤` 방식으로 만들어져 관리되게 할 수 있다.

`싱글톤 레지스트리`는 다음과 같은 이점을 추가로 제공한다.

- `싱글톤` 방식으로 사용될 애플리케이션 클래스도 `public` 생성자를 가질 수 있다. 따라서, 테스트 환경에서 자유롭게 오브젝트를 생성하거나, 테스트를 위한 목 오브젝트로 대체하는 것도 간단하다. `DaoFactory`에서 `UserDao`에 `ConnectionMaker` 오브젝트를 넣어주듯이, 생성자 파라미터를 이용해서 사용할 오브젝트를 넣어줄 수도 있다.
- `싱글톤` 패턴을 제외한 스프링이 지지하는 객체지향적인 설계 방식과 원칙, 디자인 패턴 등을 적용하는 데 제약이 없다.

## 1.6.2 싱글톤 오브젝트의 상태

멀티스레드 환경에서 여러 스레드가 `싱글톤`에 접근할 수 있다. 따라서, 상태 관리에 주의를 기울여야 하는데, 기본적으로 `싱글톤`이 멀티스레드 환경에서 서비스 형태의 오브젝트로 사용되는 경우에는 상태정보를 내부에 가지고 있지 않은 `무상태(stateless)` 방식으로 만들어져야 한다.

다중 사용자의 요청을 한꺼번에 처리하는 스레드들이 동시에 `싱글톤` 오브젝트의 인스턴스 변수를 수정하는 것은 매우 위험하다. 저장 공간이 하나이므로 서로 값을 덮어쓰고 자신이 저장하지 않은 값을 읽어올 수 있기 때문이다. 따라서, `싱글톤`은 기본적으로 인스턴스 필드의 값을 변경하고 유지하는 `상태유지(stateful)` 방식으로 만들지 않는다.

`무상태(stateless)` 방식으로 클래스를 만들기 위해서 파라미터, 로컬 변수, 리턴 값등을 이용할 수 있다. 메서드 파라미터, 로컬 변수는 매번 새로운 값을 저장할 독립적인 공간이 만들어지므로 `싱글톤`이라고 해도 여러 스레드가 변수의 값을 덮어쓸 일은 없다.

```java
public Class UserDao {
    private ConnectionMaker connectionMaker; // 인스턴스 변수, 읽기 전용
    private Connection c; // 인스턴스 변수, 읽고 쓰기 전용
    private User user; // 인스턴스 변수, 읽고 쓰기 전용

    public User get(String id) throws ClassNotFoundException, SQLException {
        this.c = connectionMaker.makeConnection();
        // ...
        this.user = new User();
        this.user.setId(rs.getString("id"));
        this.user.setName(rs.getString("name"));
        this.user.setPassword(rs.getString("password"));
        // ...
        return this.user;
    }
}
```

위의 코드는 기존의 `UserDao`에서 선언한 로컬 변수 `Connection`, `User`를 인스턴스 필드로 수정한 코드다. 멀티스레드 환경에서 `싱글톤`으로 만들어진다면 위에서 설명한 대로 심각한 문제가 발생한다. 서로 값을 덮어쓰고, 자신이 저장하지 않은 값을 읽어올 것이다. 따라서, `싱글톤 빈`으로 사용되는 클래스를 만들 때는 기존의 `UserDao`처럼 개별적으로 바뀌는 정보는 로컬 변수로 정의하거나, 파라미터로 주고받으면서 사용하게 해야 한다.

그런데, 기존의 `UserDao`에서도 인스턴스 변수로 정의해서 사용한 것이 있는데, 바로 `ConnectionMaker` 인터페이스 타입의 `connectionMaker`이다. `connectionMaker`는 인스턴스 변수로 사용해도 상관이 없는데, 읽기 전용의 정보이기 때문이다.

아래와 같이 `DaoFactory`에서 `connectionMaker`에 `@Bean` 애노테이션을 붙였으므로 스프링이 관리하는 빈이 될 것이고, 별다른 설정을 하지 않았기 때문에 오브젝트 한 개만 만들어져서 `UserDao`의 `connectionMaker` 인스턴스 필드에 저장된다. 즉, `ConnectionMaker` 타입의 싱글톤 오브젝트가 들어가는 것이다.

```java
@Configuration
public class DaoFactory {
    // ...
    @Bean
    public ConnectionMaker connectionMaker() {
        return new DConnectionMaker();
    }
}
```

## 1.6.3 스프링 빈의 스코프

스프링에서는 `빈`이 생성되고, 존재하고 적용되는 범위를 `빈`의 `스코프(scope)`라고 한다. 스프링 `빈`의 기본 스코프는 `싱글톤`이며, `싱글톤` 스코프는 컨테이너 내에 한 개의 오브젝트만 만들어져서, 강제로 제거하지 않는 한 컨테이너가 존재하는 동안 계속 유지된다.

경우에 따라서 `싱글톤` 외의 스코프를 가질 수 있는데, 다음과 같다.

| 스코프                | 기능                                                                               |
| --------------------- | ---------------------------------------------------------------------------------- |
| 프로토타입(prototype) | `싱글톤`과 달리 컨테이너에 `빈`을 요청할 때마다 매번 새로운 오브젝트를 만들어준다. |
| 요청(request)         | 웹을 통해 새로운 `HTTP` 요청이 생길 때마다 오브젝트를 생성한다.                    |
| 세션(session)         | 웹의 세션과 스코프가 유사하다.                                                     |
