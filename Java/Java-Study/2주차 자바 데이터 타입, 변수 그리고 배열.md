# 2주차 자바 데이터 타입, 변수 그리고 배열

## Categories

- [프리미티브 타입 종류와 값의 범위 그리고 기본 값](#프리미티브-타입-종류와-값의-범위-그리고-기본-값)
- [프리미티브 타입과 레퍼런스 타입](#프리미티브-타입과-레퍼런스-타입)
- [리터럴](#리터럴)
- [변수 선언 및 초기화하는 방법](#변수-선언-및-초기화하는-방법)
- [변수의 스코프와 라이프타임](#변수의-스코프와-라이프타임)
- [타입 변환 캐스팅 그리고 타입 프로모션](#타입-변환-캐스팅-그리고-타입-프로모션)
- [1차 및 2차 배열 선언하기](#1차-및-2차-배열-선언하기)
- [타입 추론, var](#타입-추론-var)

## 프리미티브 타입 종류와 값의 범위 그리고 기본 값

`Java`에는 총 8개의 프리미티브 타입이 정의되어 있으며, 각 프리미티브 타입에는 기본값이 설정되어 있습니다.

| 자료형  |  기본값  |  크기   | 저장 가능한 값의 범위                                  |
| :-----: | :------: | :-----: | ------------------------------------------------------ |
| boolean |  false   |  1 bit  | true, false                                            |
|  char   | '\u0000' | 16 bits | 0 ~ 65,535                                             |
|  byte   |    0     | 8 bits  | -128 ~ 127                                             |
|  short  |    0     | 16 bits | -32,768 ~ 32,767                                       |
|   int   |    0     | 32 bits | -2,147,483,648 ~ 2,147,483,647                         |
|  long   |    0     | 64 bits | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 |
|  float  |   0.0    | 32 bits | 1.4E-45 ~ 3.4E38 (1.4x10^-45~3.4x10^38)                |
| double  |   0.0    | 64 bits | 4.9E-324 ~ 1.8E308 (4.9x10^-324~1.8x10^308)            |

### 실수형의 범위와 정밀도

아래의 표를 보면 `float`의 정밀도는 7자리인데, 이 것은 10진수로 7자리의 수를 오차없이 저장할 수 있다는 뜻입니다.

| 자료형 | 정밀도 |
| :----: | :----: |
| float  | 7자리  |
| double | 15자리 |

`float`는 약 `+-10^36`과 같이 큰 값을 저장할 수 있지만, 정밀도가 7자리 밖에 되지 않으므로 보다 높은 정밀도가 필요한 경우에는 변수의 타입으로 `double`을 선택해야 합니다.

## 프리미티브 타입과 레퍼런스 타입

앞서 살펴본 프리미티브 타입과 달리 레퍼런스 타입은 아래의 특징을 가집니다.

- 객체의 주소를 저장한다.
- 8개의 기본형을 제외한 나머지 타입

레퍼런스 타입의 변수(또는 참조변수)를 선언할 때는 변수의 타입으로 클래스의 이름을 사용하므로 클래스의 이름이 참조변수의 타입이 됩니다.

그래서 새로운 클래스를 작성한다는 것은 새로운 참조형을 추가하는 셈입니디다.

### 레퍼런스 타입의 변수 선언

프리미티브 타입의 변수와 같이 변수이름 앞에 타입을 적어주는데 레퍼런스 타입은 클래스의 이름입니다.

```Java
클래스이름 변수이름; // 변수의 타입이 기본형이 아닌 것들은 모두 참조변수입니다.
```

다음은 `Date`클래스 타입의 참조변수 `today`를 선언한 것입니다.

참조변수는 `null` 또는 객체의 주소를 값으로 갖으며 참조변수의 초기화는 다음과 같이 할 수 있습니다.

```Java
Date today = new Date(); // Date객체를 생성해서, 그 주소를 today에 저장
```

객체를 생성하는 연산자 `new`의 결과는 생성된 객체의 주소이며, 이제 참조변수 `today`를 통해서 생성된 객체를 사용할 수 있게 됩니다.

## 리터럴

프로그래밍에서 `상수`를 '값을 한 번 저장하면 변경할 수 없는 저장공간'으로 정의하였기 때문에, 이와 구분하기 위하여 실제 상수값을 다른 이름으로 불러야 했습니다.

그래서 `리터럴`이라는 용어를 사용합니다.

| 구분            | 설명                            |
| :-------------- | :------------------------------ |
| 변수(variable)  | 하나의 값을 저장하기 위한 공간  |
| 상수(constant)  | 값을 한번만 저장할 수 있는 공간 |
| 리터럴(literal) | 그 자체로 값을 의미             |

```Java
int year = 2021;
final int MAX_POWER = 200;
// year -> 변수
// MAX_POWER -> 상수
// 2021, 200 -> 리터럴
```

## 변수 선언 및 초기화하는 방법

변수를 선언한 이후부터는 변수를 사용할 수 있으나, 그 전에 반드시 변수를 '초기화(initialization)'해야 합니다.

메모리는 여러 프로그램이 공유하는 자원이므로 전에 다른 프로그램에 의해 저장된 '알 수없는 값(쓰레기값, garbage value)이' 남아있을 수 있기 때문입니다.

변수의 종류에 따라 변수의 초기화를 생략할 수도 있지만, 변수는 사용되기 전에 적절한 값으로 초기화 하는 것이 좋습니다.

지역 변수는 사용되기 전에 초기화를 반드시 해야 하지만 클래스 변수와 인스턴스 변수는 초기화를 생략할 수 있습니다.

```Java
class Test {
	public static void main(String[] args) {
    int year; // 변수 선언
		year = 0; // year 변수 초기화
		int age  = 19; // 변수의 선언과 동시에 초기화

		year = age + 2021; // 변수 age의 값에 2021을 더해서 변수 year에 저장
		age  = age + 1; // 변수 age에 저장된 값을 1 증가시킨다.

		System.out.println(year); // 2021
		System.out.println(age); // 20
	}
}
```

## 변수의 스코프와 라이프타임

### 변수의 스코프

변수의 스코프란 변수에 대하여 접근과 변수가 존재할 수 있는 영역을 의미합니다.

변수의 종류에 따라 스코프를 구분해볼 수 있습니다.

|  변수의 종류  | 변수의 스코프                      |  선언 위치  | 생성 시기(메모리 할당 시기) |
| :-----------: | :--------------------------------- | :---------: | :-------------------------- |
|   지역 변수   | 해당 메서드                        | 메서드 영역 | 변수가 선언되었을 때        |
|  클래스 변수  | 클래스 전역(클래스, 인스턴스 공유) | 클래스 영역 | 클래스가 메모리에 로딩될 때 |
| 인스턴스 변수 | 개별 인스턴스                      | 클래스 영역 | 인스턴스가 생성될 때        |

### 변수의 라이프타임

|  변수의 종류  | 라이프타임                     |
| :-----------: | :----------------------------- |
|   지역 변수   | 생성 ~ 메서드 종료까지         |
|  클래스 변수  | 생성 ~ GC에 의해 소멸될 떄까지 |
| 인스턴스 변수 | 생성 ~ 프로그램 종료까지       |

## 타입 변환, 캐스팅 그리고 타입 프로모션

### 형변환 (타입 변환)

프로그래밍을 할 때, 서로 다른 타입간의 연산을 수행할 필요가 있습니다.

이러한 경우에 연산을 수행하기 전에 타입을 일치시켜야 하는데, 변수나 리터럴의 타입을 다른 타입으로 변환하는 것을 형변환(casting)이라고 합니다.

프리미티브 타입에서 `boolean` 타입을 제외한 나머지 타입들은 서로 형변환이 가능합니다. 그리고, 프리미티브 타입과 레퍼런스 타입 간에는 형변환이 불가능합니다.

### 형변환 방법

형변환의 방법은 아주 간단한데, 형변환하고자 하는 변수나 `리터럴`의 앞에 변환하고자 하는 타입을 괄호와 함께 붙여주면 됩니다.

```
(타입)피연산자
```

```Java
double d = 12.3;
int i = (int)d; // 12
```

### 명시적 형변환

형변환되는 변수의 타입의 표현범위가 저장될 변수의 타입의 표현범위보다 넓을 경우에 데이터의 손실이 발생할 수 있습니다.

```Java
double d1 = 1.2345;
int i1 = (int)d1; // 1. 손실 발생
// 위와 같이 double보다 표현 범위가 좁은 int 타입의 변수에 double 타입의 값 1.2345를 저장할 때 손실이 발생합니다.

double d2 = 2.0;
int i2 = (int)d2; //2. 손실 없음
// 위와 같이 double 타입의 값이 2.0일때는 손실이 발생하지는 않습니다.
```

### 자동 형변환 (타입 프로모션)

경우에 따라 형변환을 생략할 수도 있습니다. 이 경우에는 컴파일러가 생략된 형변환을 자동적으로 추가합니다.

```Java
float f = 1234; // float f = (float)1234;와 같습니다.
```

자동 형변환의 경우 형변환되는 변수의 타입의 표현범위가 저장될 변수의 타입보다 표현범위가 넓을 경우 에러가 발생합니다.

```Java
byte b = 200; // Error. byte의 범위(-128~127)를 넘는 값을 저장하므로 에러가 발생합니다.
byte b = (byte)1200; // 자동 형변환이 아닌 명시적 형변환(casting)을 해줬으므로 에러가 발생하지 않습니다.
```

자동 형변환의 규칙은 다음과 같습니다.

`byte` -> `char` -> `int` -> `long` -> `float` -> `double`

`char` -> `int`

표현범위가 좁은 타입에서 더 넓은 타입으로 형변환하는 경우에는 자동 형변환이 가능합니다.

## 1차 및 2차 배열 선언하기

### 1차원 배열의 선언과 초기화

배열은 동일한 타입의 변수를 여러개가 필요할 때 사용될 수 있습니다.

1차원 배열의 선언과 초기화는 아래와 같이 할 수 있습니다.

```Java
int[] arr1; // 배열 선언
int arr2[]; // 배열 선언
int[] arr3 = new int[3]; // 배열 선언, int 타입 3개만큼 메모리 할당, 초기화 (기본값 0으로 초기화)
int[] arr4 = {1, 2, 3}; // 배열 선언, 초기화
int[] arr5 = new int[] {1, 2, 3}; // 배열 선언, 초기화

arr1 = {1, 2, 3}; // Error. 초기화 없이 선언된 배열이므로 에러가 발생합니다.
arr1 = new int[] {1, 2, 3}; // Good. 초기화 없이 선언된 배열에 값을 저장할 메모리를 할당하고 값을 초기화하므로 에러가 발생하지 않습니다.

arr1 = new int[3]; // int 타입 3개만큼 메모리 할당. 기본값 0으로 초기화
arr1[0] = 1; // 0 index에 값 1 저장
```

### 2차원 배열의 선언과 초기화

2차원 배열은 배열의 배열이라고 생각하면 됩니다.

2차원 배열의 선언과 초기화는 아래와 같이 할 수 있습니다.

```Java
int[][] arr1;
int[] arr2[];
int arr3[][];
int[][] arr4 = new int[2][3];
int[][] arr5 = {{1, 2, 3}, {4, 5, 6}};
int[][] arr6 = new int[][]{{1, 2, 3}, {4, 5, 6}};

arr1 = {{1, 2, 3}, {4, 5, 6}}; // Error. 초기화 없이 선언된 배열이므로 에러가 발생합니다.
arr1 = new int[][] {{1, 2, 3}, {4, 5, 6}}; // Good. 메모리 할당 후 사용하므로 에러가 발생하지 않습니다.

arr1 = new int[2][3]; // int 타입의 3개 X 2개 만큼 메모리 할당. 기본값 0으로 초기화
arr1[0][0] = 1; // 2차원 배열 arr1의 첫 번째 배열 arr1[0]의 0 index에 값 1 저장
```

## 타입 추론, var

타입 추론이란 개발 당시에는 타입이 정해지지 않았지만, 컴파일러가 그 타입을 유추하는 것을 의미합니다.

`Java 9`까지는 제네릭스나 람다식에서만 타입추론을 지원했지만 `Java 10`부터는 타입추론을 위한 `var` 키워드가 추가되어 변수 선언에 사용할 수 있게 되었습니다.

```Java
var bool = true; // boolean
var c = 'a'; // char
var i = 100; // int
var l = 200L; // long
var f = 1.1f; // float
var d = 2.1; // double
var s = "str"; // String
```
