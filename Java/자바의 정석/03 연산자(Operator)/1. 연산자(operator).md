# 목차

- [1.1 연산자와 피연산자](#11-연산자와-피연산자)
- [1.2 식과 대입연산자](#12-식과-대입연산자)
- [1.3 연산자의 종류](#13-연산자의-종류)
- [1.4 연산자의 우선순위와 결합규칙](#14-연산자의-우선순위와-결합규칙)
- [1.5 산술 변환(usual arithmetic conversion)](#15-산술-변환usual-arithmetic-conversion)

# 1. 연산자(operator)

## 1.1 연산자와 피연산자

```
연산자(operator)  연산을 수행하는 기호(+, -, *, / 등)
피연산자(operand) 연산자의 작업 대상(변수, 상수, 리터럴, 수식)
```

## 1.2 식과 대입연산자

연산자와 피연산자를 조합하여 표현한 것을 `식(expression)`이라고 한다. 그리고 식을 계산하여 결과를 얻는 것을 '식을 평가(evaluation)한다'고 한다.

아래와 같이 대입 연산자 `=`를 사용해서 값을 저장하여 사용한다.

```Java
int i = 2;
int j = i * 3 + 4;
```

## 1.3 연산자의 종류

|    종류     |           연산자           | 설명                                       |
| :---------: | :------------------------: | ------------------------------------------ |
| 산술 연산자 |   +, -, \*, /, %, <<, >>   | 사칙 연산과 나머지 연산                    |
| 비교 연산자 |    >, <, >=, <=, ==, !=    | 크고 작음과 같고 다름을 비교               |
| 논리 연산자 | &&, \|\| , !, &, \| , ^, ~ | '그리고(AND)'와 '또는(OR)'으로 조건을 연결 |
| 대입 연산자 |             =              | 우변의 값을 좌변에 저장                    |
|    기타     |   (type), ?:, instanceof   | 형변환, 삼항, instanceof 연산자            |

## 1.4 연산자의 우선순위와 결합규칙

|             식             | 설명                                                                                                                                                                                                                                      |
| :------------------------: | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|         x << 2 + 1         | 쉬프트 연산자(<<)는 덧셈 연산자보다 우선순위가 낮다.<br>따라서 왼쪽의 식은 'x << (2 + 1)'과 같다.                                                                                                                                         |
|      data & 0xFF == 0      | 비트 연산자(&)는 비교 연산자(==)보다 우선순위가 낮으므로 비교연산자 후에 비트연산이 수행된다.<br>따라서 왼쪽의 식은 'data & (0xFF == 0)'과 같다.                                                                                          |
| x < -1 \|\| x > 3 && x < 5 | 논리 연산자 중에서 AND를 의미하는 '&'와 '&&'가 OR를 의미하는 '\|'와 '\|\|'보다 우선순위가 높다.<br>이처럼 수식에 AND와 OR가 함께 사용되는 경우는 다음과 같기 괄호를 사용해서 우선순위를 명확히 하는 것이 좋다.<br>x < -1 \|\| 3 && x < 5) |

### 연산자의 결합규칙

```
1. 산술 > 비교 > 논리 > 대입. 대입은 우선순위가 가장 낮다.
2. 단항(1) > 이항(2) > 삼항(3). 단항 연산자의 우선순위가 가장 높다ㅏ.
3. 단항 연산자와 대입 연산자를 제외한 모든 연산의 진행방향은 왼족에서 오른쪽이다.
```

|    종류     | 결합규칙 | 연산자                                        | 우선순위 |
| :---------: | :------: | --------------------------------------------- | :------: |
| 단항 연산자 |    <-    | ++, --, +, -, ~, !, (type)                    |   높음   |
| 산술 연산자 |    ->    | \*, /, %                                      |          |
| 산술 연산자 |    ->    | +, -                                          |          |
| 산술 연산자 |    ->    | <<, >>                                        |          |
| 비교 연산자 |    ->    | <, >, <=, >=, instanceof                      |          |
| 비교 연산자 |    ->    | ==, !=                                        |          |
| 논리 연산자 |    ->    | &                                             |          |
| 논리 연산자 |    ->    | ^                                             |          |
| 논리 연산자 |    ->    | \|                                            |          |
| 논리 연산자 |    ->    | &&                                            |          |
| 논리 연산자 |    ->    | \|\|                                          |          |
| 삼항 연산자 |    ->    | ?:                                            |          |
| 대입 연산자 |    <-    | =, +=, -=, \*=, /=, %=, <<=, >>=, &=, ^=, \|= |   낮음   |

## 1.5 산술 변환(usual arithmetic conversion)

이항 연산자는 두 피연산자의 타입이 일치해야 연산이 가능하다. 예를 들어 `int` 타입과 `float` 타입을 덧셈하는 경우, 형변환 연산자를 사용해서 피연산자의 타입을 모두 `int` 또는 `float`로 일치시켜야 한다.

```Java
int i = 1;
float f = 2.0;
float res = (float)i + f; // 형변환으로 두 피연산자의 타입을 일치시킨다.
```

대부분의 경우, 두 피연산자의 타입 중에서 더 큰 타입으로 일치시킨다. 더 작은 값으로 형변환하면 값의 손실이 발생할 수 있기 때문이다.

따라서 위의 코드에서처럼 더 큰 타입으로 형변환할 때 형변환 연산자를 생략할 수 있다.

```Java
int i = 1;
float f = 2.0;
float res = i + f; // 큰 타입으로 형변환할 때, 형변환 연산자를 생략할 수 있다.
```

이처럼 연산 전에 피연산자의 타입을 일치시키기 위해 자동 형변환되는 것을 `산술 변환` 또는 `일반 산술 변환`이라 하며, 이 변환은 이항 연산뿐만 아니라 단항 연산에서도 일어난다.

`산술 변환`의 규칙은 다음과 같다.

1. 두 연산자의 타입을 같게 일치시킨다. (더 큰 타입으로 일치시킨다.)

```
long   + int    -> long   + long    -> long
float  + int    -> float  + float   -> float
double + float  -> double + double  -> double
```

2. 피연산자의 타입이 `int`보다 작은 타입이면 `int`로 변환된다.

```
byte + short -> int + int -> int
char + short -> int + int -> int
```

첫 번째 규칙은 피연산자의 값손실을 최소화하기 위한 것이고, 두 번째 규칙은 정수형의 기본 타입인 `int`가 가장 효율적으로 처리할 수 있는 타입이며, `char`, `short` 타입의 경우 표현범위가 좁아서 연산중에 오버플로우가 발생할 가능성이 높기 때문에 만들어진 것이다.
